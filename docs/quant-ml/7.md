# 7.QML 技术

> 蝴蝶计算的不是月份，而是瞬间，它有足够的时间。
> 
> —罗宾德拉纳特·泰戈尔

在我们对各种量子算法和平台的探索中，我们经历了有趣的一点，量子计算机是概率性的，意味着它可以返回多个答案。其中有些可能是你正在寻找的答案，有些可能不是。起初，这听起来像是一件坏事，因为当你问计算机同样的问题时，它会返回一个不同的答案，这不会产生信心！然而，在量子计算机中，返回多个答案可以给出关于计算机置信度的重要信息。

如果我们给计算机看一个苹果的图像，让它给同一个图像贴 100 次标签，而它给的答案是*苹果* 100 次，那么计算机就确信这个图像是一个苹果。但是，如果它 50 次返回答案 apple，50 次返回答案 raspberry，那么计算机就不确定我们正在向它显示的图像。如果我们给它展示一个有苹果*和*覆盆子的图像，它会是完全正确的！在设计能够做出复杂决策和了解世界的系统时，这种不确定性可能非常强大。

Note

本章重点介绍量子计算和机器学习的高级算法和技术。介绍了 D-Wave 的退火平台及其优化能力。D-Wave、pyQuil 和 Qiskit 中的代码从理论的角度涵盖了 VQE、QAOA 和曲波。

第 [6](6.html) 章讨论了量子线性模型和量子相位估计(QPE)的实现，特别是基于量子傅立叶变换(QFT)的算法。然而，QPE 和一些其他算法的应用并不局限于有限数量的情况；相反，常见的是，一旦数据可用于量子计算设备，就用诸如量子相位估计和*矩阵求逆*(HHL 算法)之类的算法对其进行处理。迄今为止， *HHL 算法*已经在各种量子计算机上实现。

各种各样的经典数据分析和机器学习协议通过对高维向量空间中的向量执行矩阵运算来操作。然而，这正是量子力学的全部内容！量子力学利用高维向量空间(如希尔伯特空间)中向量的矩阵运算。这些方法背后的关键成分是， *n* 个量子位*或量子位*的量子状态是 2<sup>nT9】维复向量空间中的向量，因此，对量子位执行量子逻辑运算或测量将相应的状态向量乘以 2<sup>nT13】×2<sup>nT17】矩阵。</sup></sup></sup>

量子计算机执行常见的线性代数运算，例如傅立叶变换[116]，寻找特征向量和特征值[116]，以及在时间上求解 2<sup>*【n】*</sup>维向量空间上的线性方程组，其在 *n* 中是多项式，比它们最著名的经典对应项[115]快得多。后者被称为哈罗、哈西迪姆和劳埃德(HHL)算法[115]。

## HHL 算法(矩阵求逆)

线性系统的量子算法首先由哈罗、哈西迪姆和劳埃德(HHL) [115]提出。HHL 算法是许多量子机器学习协议的基础，但它是一种具有许多条件的重要算法。本章着眼于算法的实现，以便更好地理解它是如何工作的以及何时有效地工作。实践练习来源于参考文献[113]和[114]。

用于反演线性方程的 HHL 算法是一个基本的子程序，支撑着许多量子机器学习算法。该算法的目标是使用量子计算机求解*A****x***=***b***，其中 ***x*** 和 ***b*** 用“粗体”表示，表示它们是向量。求解 ***x*** 的问题，尝试通过获取算子 *A* 的*期望值*，假设为埃尔米特，用 ***x*** ，***x***<sup>和 *A* ***x*** 代替直接获取*的值当在量子计算机上求解时，这被认为是有用的，因为量子系统通常为一些测量提供概率。通常，这些运算符是泡利运算符 X、Y、z。然后，测量的概率可以转换为这些运算符的期望值。*</sup>

HHL 算法将问题*a****x***=***b***通过将向量 ***x*** 表示为量子态∣ *x* ⟩和向量***b***∈*c*<sup>*n*</sup>表示为量子态∣ *b 因此，等式 *Ax* = *b* 可以通过将等式两边乘以*A*T38】1A*A*的倒数来求解。然后，根据 HHL 算法，我们可以构造与*a*t44】1∣*b*⟩.成正比的量子态一般来说，当 a 有零个特征值(不是平方的)时，那么该算法可以用来找到最小化[117]|*a*|*x*⟩−|*b*⟩|.的状态∣*x*⟩*

如果{| *v* <sub>*i*</sub> ⟩}和{ *λ* <sub>*i*</sub> }分别是 *A* 的特征向量和特征值，其中 0<*λ*<sub>*I*</sub><1，那么状态∣ *b* ⟩可以写成特征向量的线性组合如下

![$$ \left\{|\left.\ {v}_i\right\rangle \right\},\mid \left.\ b\right\rangle =\sum \limits_{i=1}^N{b}_i\mid \left.\ {E}_i\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equa.png)

HHL 算法旨在以![$$ \sum \limits_{i=1}^N{\alpha}_i\frac{1}{\lambda_i}\mid \left.\ {v}_i\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq1.png)的形式获得∣ * x * ⟩。HHL 程序使用量子子程序*相位估计*找到 *A* 的特征值，如第 [6](6.html) 章所述。

图 [7-1](#Fig1) 所示的算法使用了三组量子位:单个辅助量子位，一个存储 *A* 的特征值的寄存器，以及内存量子位(给 store∣ *b* ⟩和∣ *x* ⟩).

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig1_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig1_HTML.png)

图 7-1

HHL 算法被细分为 QPE(量子相位估计)以确定特征值，受控旋转 R <sub>y</sub> 以提取特征值信息，以及非计算以恢复相位估计

在图 [7-1](#Fig1) 中，执行以下动作。

1.  量子相位估计提取 A 的特征值

2.  辅助量子比特的受控旋转

3.  用逆量子相位估计解算 <sup>[1](#Fn1)</sup> 。

这些步骤描述如下。

首先，由于特征值 *λ* <sub>*i*</sub> 都是二进制形式(0。*a*<sub>1</sub>*a*<sub>2</sub>*a*<sub>3</sub>……)∣*λ*<sub>*I*</sub>⟩=∣*a*<sub>1</sub>*a*<sub>2*a*<sub>3</sub>由于谱定理说每个埃尔米特矩阵都有一个特征向量的正交基，我们可以写出矩阵![$ A\equiv \sum \limits_i{\lambda}_i\mid \left.\ {v}_i\right\rangle \left\langle {v}_i\right| $](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq2.png)和![$ \mid \left.\ b\right\rangle =\sum \limits_n{b}_n\mid \left.\ {E}_n\right\rangle $](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq3.png)，其中∣*e*<sub>*n*</sub>⟩是一个特征向量 *A* 和特征值*λ*<sub>*n*</sub>>c。这里 *C* 是一个*比例因子*以防止受控旋转变得不实际，这表明从实际估算的角度来看，选择小于 *λ* 的最小值的 *C 是合理的；这正式表述为![$ C=O\left(\frac{1}{\kappa}\right) $](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq4.png)，其中 *κ* 是矩阵 *A* 的*条件号* <sup>[ 2 ](#Fn2)</sup> 。为了更好地形象化这一点，让我们用这本书网站上的 Jupyter 笔记本`HHL_qiskit.ipynb`做一些练习。代码改编自赵等人<sup>[3](#Fn3)</sup>【113】并在 Qiskit 中完成。*</sub>

如果你对不同的编码选项感兴趣，谷歌的 Cirq 教程在 GitHub [119]上的 [`https://github.com/quantumlib/Cirq/blob/master/examples/hhl.py`](https://github.com/quantumlib/Cirq/blob/master/examples/hhl.py) 有 HHL 算法实现的全面展示。

我们通过对一个 2 × 2 矩阵求逆来建立方程*A****x***=***b***的解，其中![$$ A=\frac{1}{2}\left[\begin{array}{cc}3&amp; 1\\ {}1&amp; 3\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq5.png) anb ![$$ b=\left[\begin{array}{c}1\\ {}0\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq6.png)。矩阵𝐴被编码为一个哈密顿量，而𝑏在一个寄存器中。我们总共需要五个量子位和一个经典寄存器用于选择后操作，另一个量子位和一个额外的经典寄存器用于创建交换测试，以将结果与理想状态进行比较。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figa_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figa_HTML.jpg)

```
import numpy as np
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit import execute
from qiskit import BasicAer
π = np.pi
q = QuantumRegister(6)
c = ClassicalRegister(2)
hhl = QuantumCircuit(q, c)

Listing 7-1aLibraries and for HHL_qiskit.ipynb

```

在下一步骤中，执行*相位估计*以在附加寄存器中映射(或编码)矩阵𝐴的特征值。量子相位估计算法执行以下映射

![$$ {\left(|{\left.\ 0\right\rangle}^{\otimes n}\right)}^C\mid {\left.\ u\right\rangle}^I\mid {\left.\ 0\right\rangle}^S\mapsto {\left(|{\left.\ \varphi \right\rangle}^{\otimes n}\right)}^C\mid {\left.\ u\right\rangle}^I\mid {\left.\ 0\right\rangle}^S $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equb.png)

(7.1)

其中∣ *u* ⟩是某酉算子 *U* 的一个特征向量，具有未知的特征值*e*T6】T7】I2*πφ*t11*I*表示复平面而不是指数。

等式 [7.1](#Equb) 中 kets 上的上标与存储相应状态的寄存器名称有关。

在 HHL 算法中，输入寄存器以特征向量的叠加开始(即![$$ \mid \left.\ b\right\rangle =\sum \limits_n{b}_n\mid \left.\ {E}_n\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq7.png))。酉算子由 *e* <sup>* iAt *</sup> 给出。为避免分母中 2 *π* 的因子，往往将演化时间*t*T11】0 取为 2 *π* 。在此步骤中，我们考虑时钟寄存器控制的哈密尔顿模拟门 *U* 。有了这些假设，最初的目标是创建一个应用于不同持续时间的哈密顿量的𝐴叠加。因为本征值总是位于复单位圆上，所以本征结构由叠加中不同演化的分量揭示。因此，条件哈密顿量的演化可以表示为张量态积上的![$$ \sum \limits_{\tau =0}^{T-1}\mid {\left.\ \tau \right\rangle \left\langle \tau \right|}^C\otimes {e}^{iA\tau {t}_0/T} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq8.png)∣*ψ*t20】0⟩⊗∣*b*⟩.这一操作使状态∣*b*⟩在由状态∣*ψ*0⟩.确定的时间段𝜏内由哈密顿量𝐴控制

由于状态∣*ψ*T2】0⟩具有 0 和 *T* 之间所有可能时间步长的叠加，因此结果是所有可能演变的叠加。我们需要适当选择时间步长𝑇的数量和总演化时间*t*t8 以允许对特征值的二进制表示进行编码。

作为 HHL 算法的一部分，在*量子相位估计* (QPE)过程中的最后一步，应用逆傅立叶变换，将编码𝐴特征值的相位写入新寄存器。

应用 *A* 下的相位估计有助于计算*λ*<sub>T5】n</sub>。因此，在这一步，我们在一个附加的寄存器中对矩阵𝐴的特征值进行编码。图 [7-2](#Fig2) 显示了相位估计电路。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig2_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig2_HTML.jpg)

图 7-2

HHL 算法的 QPE 电路

在特征值为 2 的幂的 2 × 2 矩阵中，我们选择 *t* <sub>0</sub> = 2 *π* 和 *T* = 4 来获得具有两个受控进化的精确结果。

```
# Superposition
hhl.h(q[1])
hhl.h(q[2])
# Controlled-U0
hhl.cu3(-π / 2, -π / 2, π / 2, q[2], q[3])
# hhl.cu1(3 * π / 4, q[2], q[3])
hhl.cp(3 * π / 4, q[2], q[3])
hhl.cx(q[2], q[3])
#hhl.cu1(3 * π / 4, q[2], q[3])
hhl.cp(3 * π / 4, q[2], q[3])
hhl.cx(q[2], q[3])
# Controlled-U1
hhl.cx(q[1], q[3]);

Listing 7-1bSuperposition and Quantum Circuit Definition HHL_qiskit.ipynb

```

然后，量子逆傅立叶变换将相位写入寄存器。

```
hhl.swap(q[1], q[2])
hhl.h(q[2])
hhl.cp(-π / 2, q[1], q[2])
hhl.h(q[1]);

Listing 7-1cInverse QFT HHL_qiskit.ipynb

```

QFT 分解后系统的状态由![$$ \sum \limits_i{\beta}_i\mid \left.\ {E}_i\right\rangle \mid \left.\ {\lambda}_i\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq9.png)近似给出，其中![$$ \mid \left.\ b\right\rangle =\sum \limits_i{b}_i\mid \left.\ {E}_i\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq10.png)。这里，∣ * b * ⟩是𝐴.本征基中向量 *b* 的编码

下一步是对∣*λ*T2】T3】It5】⟩进行运算，使其反转。在这种情况下， *A* 的特征值为 *λ* <sub>1</sub> = 2 = 10(二进制)和 *λ* <sub>2</sub> = 1 = 01。特征值的倒数为![$$ {\lambda_1}^{-1}=\raisebox{1ex}{$1$}\!\left/ \!\raisebox{-1ex}{$2$}\right.\Longrightarrow 2{\lambda_1}^{-1}=01 $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq11.png)和*λ*<sub>2</sub><sup>—1</sup>= 1⟹2*λ*<sub>2</sub><sup>—1</sup>= 10。在这种情况下，*交换*门获得状态![$$ \sum \limits_i{b}_i\mid \left.\ {E}_i\right\rangle \mid \left.\ 2{\lambda_i}^{-1}\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq12.png)，该状态编码特征值的倒数。

```
hhl.swap(q[1], q[2]);

```

在应用 *A* 下的相位估计来计算*λ*<sub>T5】n</sub>之后，我们将副量子位围绕 Y 轴旋转![$$ {\sin}^{-i}\frac{C}{\lambda_n} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq13.png)的角度。完成辅助量子位的这种受控旋转是为了获得接近如下的状态

![$$ \sum \limits_i{b}_i\left|\left.\ {E}_i\right\rangle \right|\left.\ 2{\lambda_i}^{-1}\right\rangle \left[\frac{C}{\lambda_i}|\left.\ 1\right\rangle +\sqrt{1-\frac{C^2}{{\lambda_i}^2}\mid \left.0\right\rangle}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equc.png)

(7.2)

```
hhl.cu3(0.392699, 0, 0, q[1], q[0])  # Controlled-RY0
hhl.cu3(0.19634955, 0, 0, q[2], q[0]);  # Controlled-RY1

Listing 7-1dAncilla Rotation HHL_qiskit.ipynb

```

执行量子计算时，除了将算法所需信息存储在最终寄存器中的操作之外，您必须取消所有操作的计算。这一步是必要的，以防寄存器纠缠在一起，影响结果。在本例中，步骤 2 中的 QPE 必须是未计算的。在不计算之后，最终期望的状态是

![$$ \sum \limits_i{b}_i\left|\left.\ {E}_i\right\rangle \right|\left.\ 0\right\rangle \left[\frac{C}{\lambda_i}|\left.\ 1\right\rangle +\sqrt{1-\frac{C^2}{{\lambda_i}^2}\mid \left.0\right\rangle}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equd.png)

(7.3)

```
hhl.swap(q[1], q[2])
hhl.h(q[1])
hhl.cp(π / 2, q[1], q[2]) # Inverse(Dagger(Controlled-S))
hhl.h(q[2])
hhl.swap(q[2], q[1])
# Inverse(Controlled-U1)
hhl.cx(q[1], q[3])
# Inverse(Controlled-U0)
hhl.cx(q[2], q[3])
hhl.cp(-3 * π / 4, q[2], q[3])
hhl.cx(q[2], q[3])
hhl.cp(-3 * π / 4, q[2], q[3])
hhl.cu3(-π / 2, π / 2, -π / 2, q[2], q[3])
# End of Inverse(Controlled-U0)
hhl.h(q[2])
hhl.h(q[1]);

Listing 7-1eUncompute Action on QPE HHL_qiskit.ipynb

```

接下来，我们通过投影到期望的状态∣1⟩.来执行后期选择为了获得预期的解决方案，需要手动准备正确的输出状态，以对结果执行交换测试。

```
# Target state preparation
hhl.rz(-π, q[4])
hhl.p(π, q[4])
hhl.h(q[4])
hhl.ry(-0.9311623288419387, q[4])
hhl.rz(π, q[4])
# Swap test
hhl.h(q[5])
hhl.cx(q[4], q[3])
hhl.ccx(q[5], q[3], q[4])
hhl.cx(q[4], q[3])
hhl.h(q[5])
hhl.barrier(q)
hhl.measure(q[0], c[0])
hhl.measure(q[5], c[1]);

Listing 7-1fPsot-Selection HHL_qiskit.ipynb

```

执行两个测量:一个用于后选择的辅助寄存器，另一个输出交换测试的结果。为了计算成功概率，我们定义了一些辅助函数。

```
def get_psuccess(counts):

    try:
        succ_rotation_fail_swap = counts['11']
    except KeyError:
        succ_rotation_fail_swap = 0
    try:
        succ_rotation_succ_swap = counts['01']
    except KeyError:
        succ_rotation_succ_swap = 0
    succ_rotation = succ_rotation_succ_swap + succ_rotation_fail_swap
    try:
        prob_swap_test_success = succ_rotation_succ_swap / succ_rotation
    except ZeroDivisionError:
        prob_swap_test_success = 0
    return prob_swap_test_success

Listing 7-1gSuccess Functions HHL_qiskit.ipynb

```

最后，电路在模拟器上运行。

```
backend = BasicAer.get_backend('qasm_simulator')
job = execute(hhl, backend, shots=100)
result = job.result()
counts = result.get_counts(hhl)
print(get_psuccess(counts))

Listing 7-1hCircuit

run HHL_qiskit.ipynb

```

这给出了 1 的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figb_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figb_HTML.jpg)

辅助设备的测量值为 1 表示矩阵转换成功。这使得系统处于与解向量∣ *x* ⟩.成比例的状态在许多情况下，你对∣ *x* ⟩的单个向量元素不感兴趣，而只对某些性质感兴趣。

如果测量辅助量子位，如果观察到 1，那么每个本征态除以 *λ* <sub>*n*</sub> ，这影响了逆。在施加幅度放大之后，状态准备电路需要被施加以成功的次数是![$$ O\left(\frac{\left\Vert A\right\Vert }{C}\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq14.png)，其相当于矩阵的条件数 *κ* 。

HHL 算法需要*o*[(log*n*)<sup>2</sup>]个量子步骤来输出∣ *x* ⟩，相比之下，在经典计算机上使用最知名的方法找到 *x* 需要*o*(*n*log*n*个步骤。

谈到 HHL 算法，有几个事实需要考虑。

*   HHL 算法性能的一个重要因素是*条件数κ* 。随着 *κ* 的增加，矩阵 *A* 趋向于向不可逆矩阵增长，并且解成比例地变得不稳定。条件数大的矩阵称为病态矩阵。

*   从量子态∣ *x* ⟩中寻找 *x* 的完整答案需要 *O* ( *N* )次重复重构 *x* 的 *N* 分量。对 HHL 的推广，如最小二乘拟合，通过允许输出比输入维数少得多来回避这个问题。

*   需要准备输入向量 b，或者在量子计算机上，或者使用 qRAM(量子 RAM)，这可能是昂贵的。

*   矩阵必须是条件良好的，并且必须能够高效地模拟*e*<sup>—*iA*</sup>。

## 曲波

*二次无约束二元优化*(曲波)，也称为无约束二元二次规划，将金融和经济学中广泛应用的各种组合优化问题统一到利用量子计算领域中应用的优化模型的机器学习中[103]。近年来，曲波已经发展成为一个数学公式，可以包含工业、科学和政府中发现的各种各样的重要组合优化问题(见 Anthony 等人【104】和 Kochenberger 等人【105】)。一旦将曲波解算器放入适当的曲波框架中，它们的力量可以用来有效地解决许多重要问题。

曲波模型作为*量子退火*领域的坚实基础具有无可争议的重要性，并且已经成为神经形态计算的研究主题。曲波模型是 D-Wave 开发的量子计算机和 IBM 开发的基于门的量子计算机实验的核心。商业领域的 IBM、Google、Amazon、Microsoft、D-Wave 和 Lockheed Martin 以及公共领域的 Los Alamos 国家实验室、Oak Ridge 国家实验室、Lawrence Livermore 国家实验室和 NASA 的 Ames 研究中心等组织正在探索曲波模型与量子计算之间关系的后果。目前，量子计算社区中的各种研究机构正在深入研究曲波模型，并评估其作为传统建模和解决方法的替代方案的有效性。

### 伊辛模型

曲波模型的重要性在于它能够包含组合优化中的几个模型。卢卡斯[110]表明，曲波模型等价于伊辛模型<sup>[4](#Fn4)</sup>【111】。*伊辛模型*是关于统计力学的*铁磁性*的非物理数学模型，在物理学中起着突出的作用。该模型使用离散变量来表示自旋状态的磁偶极矩(为+1 或–1)。自旋状态被组织成一个格子，这样每个自旋可以和它的邻居相互作用(见图 [7-3](#Fig3) )。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig3_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig3_HTML.jpg)

图 7-3

伊辛模型

伊辛模型不符合实际的物理系统。这是一个巨大的(正方形)站点网格，其中每个站点可以处于两种状态之一。每个站点都标有索引 *i* ，这两种状态分别称为–1 和+1。例如，当我们声明自旋*σ*<sub>T5】I</sub>= 1 时，我们的意思是第 *i* 个位置处于状态-1。磁行为可以通过把每个原子想象成一个自旋来理解，指向上或下。自旋可能希望逆着磁场或与磁场对齐。邻近的自旋会互相影响，但较远的自旋不会。因为自旋-自旋相互作用出现在两个自旋之间，所以有必要对成对的位置求和，以找到它对能量的总相互作用。作为一个物理类比，伊辛模型可以被认为是一个简化的玩具磁铁。

伊辛模型的*能量*根据其哈密顿量定义如下

![$$ {H}_{ising}=-\sum \limits_i{h}_i{\sigma}_i-\sum \limits_{ij}J{\sigma}_i{\sigma}_j $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Eque.png)

(7.4)

*其中 J* 代表自旋-自旋相互作用， *h* 代表外场， *σ* 是每个格点上的单个自旋。对于伊辛模型，自旋在以下范围内给定值:*σ*<sub>*I*</sub>∈{-1，+1}。从数学的角度来看，在这个方案中， *h* 和 *J* 是可调常数，其中*一个 h* 分配给*每个自旋*和*一个 J* 分配给每个*相互作用的自旋对*。

### 伊辛模型中的曲波

采用 Ising 模型形成量子粒子以促进量子系统中的计算是通过以下调整实现的。

1.  Define QUBO as follows.

    ![$$ O\left(c,{\alpha}_i;{\beta}_{ij};{q}_i\right)=c+\sum \limits_i{\alpha}_i{q}_i+\sum \limits_{i&lt;j}{\beta}_{ij}{q}_i{q}_j $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equf.png)

    (7.5)  

其中 *q* 是量子位变量 0 和 1(而不是伊辛模型中的 1 和+1)。

1.  将 *α* 和 *β* 定义为可调常数。

2.  Perform conversion between the 0/1 variables (for QUBO) and spins (Ising) via the following.

    ![$$ {q}_i=\frac{1+{\sigma}_i}{2} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equg.png)

    (7.6)  

因此，由最先进的曲波解决方法有效解决的广泛的最优化问题被在物理学应用中出现的问题的一个重要领域加入。根据 Kochenberger 和 Glover [109]，曲波模型解决的优化问题包括以下内容，但*不限于*。

*   最大独立集问题

*   最大切割问题

*   图着色问题

*   数字分割问题

*   线性排序问题

*   团划分问题

*   聚类问题

*   模块化最大化
    *   相关聚类

    *   其他的

*   任务分配问题(分布式计算机系统)

关于它与量子计算的关系，D-Wave 发表的一些论文谈到了在量子计算的背景下使用伊辛模型的优化和机器学习应用，例如[112]。

曲波模型可以用下面的表达式来表示。

![$$ \mathit{\operatorname{maximize}}\ or\ \mathit{\operatorname{minimize}}\ function\ f={x}^T Qx $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equh.png)

(7.7)

其中 *x* 是一个二进制决策向量的变量。 *Q* 是一个元素为常数的方阵 *a* <sub>*ij*</sub> 。通常假设 *Q* 是对称的或者是上三角形式，这可以在不失一般性的情况下实现。

当对于所有的 *i* 和 *j* ，除了 *i* = *j* ，*a*<sub>*ij*</sub>被替换为(*a*<sub>*ij*+*a*<sub>*Ji*</sub>/时，就产生了一个*对称形式*线性项的系数出现在矩阵的主对角线上，我们忽略任何常数。</sub>

*上三角形式*:为所有 *i* 和 *j* ，用 *j* > *i* ，*a*<sub>*ij*</sub>替换为(*a*<sub>*ij*+*a*<sub>*Ji*</sub>)；然后所有的*a*<sub>*ij*</sub>对于 *j* < *i* 都被替换为 0。如果矩阵是对称的，那么这个动作将矩阵对角线上方的*a*<sub>*ij*</sub>值加倍，主对角线下方的所有值都被设置为 0。</sub>

让我们看一个对称矩阵的例子。考虑下面的优化问题。

![$$ (\mathrm{minimize}) f=-5x-3y-8z-6w+4 xy+8 xz+2 yz+10 zw $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equ1.png)

其中变量 *x* 、 *y* 、 *z* 、 *w* 为二进制；也就是说，它们只能有值 0 和 1。

为了用曲波解决这个优化问题，我们观察以下事实。

1.  *f* 是二元变量的二次函数。它有一个线性部分(5*x*3*y*8*z*6*w*)和一个二次部分(4*xy*+8*xz*+2*yz*+10*zw*)。

2.  Binary variables satisfy *x* = *x*<sup>2</sup>, *y* = *y*<sup>2</sup>, *z* = *z*<sup>2</sup> and *w* = *w*<sup>2</sup>, since their values can be either 0 or 1\. Hence,

    ![$$ -5x-3y-8z-6w=-5{x}^2-3{y}^2-8{z}^2-6{w}^2 $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equi.png)

3.  现在，我们能够将模型写成如下矩阵形式。

    ![$$ (\mathrm{minimize}) f=(xyzw)\left[\begin{array}{c}\begin{array}{cc}-5&amp; \kern0.5em 2\\ {}\kern0.75em 2&amp; -3\end{array}\\ {}\begin{array}{cc}\kern0.5em 4&amp; \kern0.75em 1\\ {}\kern0.5em 0&amp; \kern0.75em 0\end{array}\end{array}\kern1em \begin{array}{c}\begin{array}{cc}\kern0.75em 4&amp; \kern0.75em 0\\ {}\kern0.75em 1&amp; \kern0.75em 0\end{array}\\ {}\begin{array}{cc}-8&amp; \kern0.75em 5\\ {}\kern0.5em 5&amp; -6\end{array}\end{array}\right]\left[\begin{array}{c}x\\ {}y\\ {}z\\ {}w\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equ2.png)

4.  结式矩阵可以写成方程 [7.7](#Equh) 的形式，其中 *x* 为二元变量的列向量。注意，线性项的系数出现在 *Q* 矩阵的主对角线上。

    唯一的*约束*是将 0 或 1 作为决策变量的值的限制，除此之外*曲波是一个无约束的*模型。曲波的所有问题数据都包含在 *Q* 矩阵中。

5.  模型的解如下:*f*= 11；*x*=*w*= 1； *y* = *z* = 0。

本章稍后将使用 pyQuil 探讨这个问题的编程解决方案。

曲波最优化问题的其他例子可以如下。

*   一个变量的曲波:5 *x* + 8

*   两个变量的曲波:10+3*x*—6*y*+9*xy*

*   三变量曲波:2*xy*+3*xz*-*yz*

这些特征使得曲波成为组合优化问题的特别有吸引力的建模框架，作为经典约束公式的替代。总之，曲波模型属于 NP 难问题。这一点的实际意义在于，除了小的问题实例之外，为寻找“最优”解而设计的精确解算器(例如，商用的 CPLEX 解算器( [`www.ibm.com/uk-en/analytics/cplex-optimizer`](http://www.ibm.com/uk-en/analytics/cplex-optimizer) ))很可能不成功。使用这种方法，实际规模的问题可能会运行几天甚至几周，而不会产生高质量的解决方案。幸运的是，正如我们在接下来的章节中所披露的，通过使用旨在在适度的计算机时间内找到高质量但不一定是最优的解决方案的方法，正在取得令人印象深刻的成功。正如你在本章中看到的，这些方法为经典和量子计算的结合提供了有价值的可能性。

## 变分量子电路

在第 [6](6.html) 章中，你看到了从伊辛模型中得到的量子优化的灵感，这与铁磁性的物理学有关。通常，薛定谔方程可以用来研究和模拟单个量子粒子的行为和演化。然而，现实世界的现象依赖于许多不同量子系统之间的相互作用。对模拟物理系统的多体哈密顿量的研究是凝聚态物理、分子动力学和模拟的中心主题。*变分方法*在量子机器学习实践和当前研究中至关重要，因此，我们花了一些时间试图解决这些想法的基础。

目前，由于希尔伯特空间的特性，多体哈密顿量本质上很难在经典计算机上建模和研究，希尔伯特空间的维度随着系统中粒子的数量呈指数增长。因此，对于经典计算机来说，寻找这些运算的特征值变得不可行。这就是量子计算机变得非常有用的地方。它允许我们用更少的开销来研究这些多体系统，因为所需的量子比特数只是多项式增长。对于一台完美的量子计算机来说，各种各样的任务应该成为日常工作的一部分。

然而，尽管使用量子计算机解决与多体物理和分子模拟相关的问题似乎很有吸引力，但当前和近期的量子计算机远非完美，并存在不完美之处。这就是为什么在近期有噪声的量子计算机上运行需要深层电路的长算法仍然是一个挑战(目前是紧张研究的主题)。使用低深度量子电路制备量子态是小型量子计算机最有前景的近期应用之一，特别是如果电路足够短，门的保真度足够高，可以在没有量子纠错的情况下执行。这种量子态制备可用于变分方法，优化电路中的参数，以最小化给定问题哈密顿量的构造量子态的能量。

自 2013 年以来，已经研究和开发了一种算法(见参考文献[120]和[121])，这些算法专注于从不完美的量子计算机中获得优势。基本思想是运行一个简短的门序列，其中一些门被参数化。然后，该过程读出结果，在经典计算机上调整参数，并在量子硬件上用新参数重复计算。通过这种方式，在量子和经典处理单元之间创建了一个迭代循环，从而创建了如图 [7-4](#Fig4) 所示的经典-量子混合算法。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig4_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig4_HTML.png)

图 7-4

混合量子经典系统的变分电路

这些算法被称为*变分*以反映改变参数的变分方法。

这种量子态制备可用于变分方法，优化电路中的参数，以最小化给定问题哈密顿量的构造量子态的能量。由于这些原因，变分电路也被称为*参数化量子电路*。

这些变分算法如图 [7-5](#Fig5) 所示，为我们提供了问题的近似解。虽然不是 100%完美，但他们可以给我们接近完美的答案。这就是它们如此有用的原因，尤其是 VQE 算法。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig5_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig5_HTML.png)

图 7-5

量子变分算法的图解(来源[122])

图 [7-5](#Fig5) 是一个*变分量子算法* (VQA)的示意图。该过程的第一步是开发一个 VQA 来定义一个成本(或损失)函数 *C* 。成本函数 *C* 对问题的解决方案进行编码。在下一步中，提出了 ansatz(即，依赖于一组可以优化的连续或离散参数 *θ* 的量子操作。然后在混合量子经典循环中用来自训练集的数据训练该 ansatz，以解决以下优化任务

![$$ {\theta}^{\ast }=\underset{\theta }{\arg\ \min }C\left(\theta \right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equj.png)

(7.8)

以下是 VQA 输入:对问题的解决方案进行编码的成本函数 *C* ( *θ* )，其参数被训练以最小化成本的 ansatz，以及可选地(如果需要)，在优化期间使用的一组训练数据。在循环的每一次迭代中，量子计算机都会有效地估计成本或其梯度。这些信息的输出被输入到一个经典的计算机中，该计算机利用优化器的能力来导航成本导数并解决方程 [7.8](#Equj) 中的优化问题。一旦满足终止条件，VQA 估计问题的解的输出。输出的形式取决于具体的任务。图 [7-5](#Fig5) 显示了一些最常见的输出类型。

在第 [4](4.html) 章中介绍的成本函数将可训练参数 *θ* 的值映射为实数。成本定义了一个*超曲面*，通常称为*成本景观*(见图 [7-5](#Fig5) )。优化器的任务是在成本范围内导航并获得全局最小值。不失一般性，成本可以表示为

![$$ C\left(\theta \right)=\sum \limits_k{f}_k\left[ Tr\left({O}_kU\left(\theta \right){\rho}_k{U}^{\dagger}\left(\theta \right)\right)\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equk.png)

(7.9)

其中 *f* <sub>*k*</sub> 是对任务进行编码的函数。离散和连续参数组成 *θ* 。{*O*<sub>*k*</sub>}定义了一个*集合*的可观测量。 *U* ( *θ* )是参数化的酉。{*ρ*<sub>*k*</sub>}由输入状态(来自训练集)组成。对于一个给定的问题， *f* <sub>*k*</sub> 可以不同，这可能导致有用成本。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig6_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig6_HTML.jpg)

图 7-6

ansatz 的示意图

由于成本函数对 VQAs 很重要，所以选择 *ansatz* 也很重要。ansatz 的形式定义了 *θ* 参数，以及如何训练它们以最小化成本。ansatz 的具体结构通常取决于任务。在某些情况下，关于问题的信息可以定制一个 ansatz，这是一个受*问题启发的 ansatz* 。其他一些 ansatz 架构是通用的，与问题无关，这意味着即使没有相关信息可用，也可以使用它们。对于等式 [7.9](#Equk) 中的成本函数，参数 *θ* 可以被编码在酉 *U* ( *θ* )中，该酉被应用于量子电路的输入状态。如图 [7-6](#Fig6) 所示， *U* ( *θ* )一般可以表示为 *S 依次*应用单位的乘积。

![$$ U\left(\theta \right)={U}_S\left({\theta}_S\right)\dots {U}_2\left({\theta}_2\right){U}_1\left({\theta}_1\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equl.png)

(7.10)

有了，

![$$ {U}_S\left({\theta}_S\right)=\prod \limits_n{W}_n{e}^{-i{\theta}_n{\mathbb{H}}_n} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equm.png)

(7.11)

其中ℍ <sub>*n*</sub> 为厄米算子， *W* <sub>*n*</sub> 为非参数化酉。

### 变分量子本征解算器(VQE)

变分量子本征解算器(VQE) [121]是一种混合量子经典算法，是优化从化学到金融等各种应用的工具。VQA 方法仅限于寻找低能本征态，并有助于最小化任何可以表示为量子可观测的目标函数。目前，确定这些量子变分算法在什么条件下成功是一个公开的问题。探索这类算法是对*噪声中等规模量子* (NISQ)计算机研究的关键部分。

在量子力学中，*变分法*是寻找量子系统低能态的典型经典方法。这种方法背后的基本思想是将试验波函数(或如前所述的 ansatz)定义为一些参数的函数，以找到这些参数的值，该值使相对于这些参数的能量期望值*最小化。这个*最小化的安萨兹*然后是对最低能量本征态*的*近似，期望值作为基态能量的上限。因此，实际上，我们最终会找到特定哈密顿量的最小特征值的上界及其对应的特征向量。VQE 帮助我们确定量子系统的基态能量。*

在 VQE，对于给定的安萨兹波函数，使能量最小化的一组参数就是问题的解。该算法由*两个*部分组成:一个*量子电路*和一个*经典优化器*。量子电路执行两项任务。

*   它以给定的变分参数为输入，生成系统的安萨兹波函数。

*   它测量能量(或哈密顿量的期望值)相对于波函数的能量。

测量结果然后被馈送到经典优化器中，以生成一组新的变分参数，这给出了较低的能量估计。图 [7-7](#Fig7) 显示了参考文献【121】中原理图中的原始 VQE 过程。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig7_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig7_HTML.png)

图 7-7

变分量子本征解算器(来源[121])

已知最小化期望〈*h*〉的特征向量对应于具有最小特征值[121]的*h*的特征向量。因此，在图 [7-7](#Fig7) 中，可以尝试所有可能的试波函数∣ *ψ* ⟩，以找到给出最小期望值的特征向量。我们如何创建这些试用状态？在该算法中，试验状态是从参数化电路中创建的。不同的波函数或安萨兹态可以通过改变参数来创建[121]。

经典的反馈决策是一些改变量子态制备参数的优化方法。对于不同的量子模块，该算法计算每个泡利项的期望值，然后通过经典计算机使用经典加法器将它们相加(见图 [7-7](#Fig7) )。然后，算法返回到经典反馈决策，为量子态准备选择更好的参数。VQE 重复这一过程，直到优化方法满意所获得的结果。

图 [7-8](#Fig8) 展示了在量子计算机上模拟一维晶格上相互作用的自旋半费米子的物理过程。该系统的哈密顿量由哈伯德 <sup>[5](#Fn5)</sup> 模型【123】描述，其中除了晶格位置之间的跳跃，具有相反自旋的费米子通过现场库仑势相互作用。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig8_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig8_HTML.png)

图 7-8

哈伯德模型的 VQE 过程示例

如图 [7-8](#Fig8) 所示，哈伯德模型的 VQE 算法从一组变分参数 *θ* <sup>(0)</sup> 开始。然后创建酉算子∣*ψ*(*θ*<sup>(0)</sup>)⟩=*u*(*θ*<sup>【0】</sup>)∣*ψ*<sub>1</sub>⟩所代表的安萨兹电路，生成安萨兹波函数∣ *ψ* ( *θ* 【T26 其通常被选择为非相互作用哈密顿量*H*T36】0 的*基态*。 系统的能量是通过测量哈密顿量相对于安萨兹的*期望值*得到的，这严格大于或等于*基态能量 E*<sub>0</sub>；也就是说，

![$$ E\left({\theta}^{(0)}\right)=\left\langle \psi \left({\theta}^{(0)}\right)\right|H\mid \left.\psi \left({\theta}^{(0)}\right)\right\rangle \ge {E}_0 $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equn.png)

在最后一步中，经典优化器根据先前的参数和能量生成一组新的参数*θ*<sup>【1】</sup>。这些新参数被反馈到安萨茨电路中，以产生一个能量更低的*新波函数*。这里，优化器被建模为基本搜索算法，其中参数空间被随机采样。重复整个过程，直到能量*e*(*θ*<sup>(*n*)</sup>)足够接近基态能量 *E* <sub>0</sub> ，使得*θ*<sup>(*n*)</sup>为问题的解，通过首先生成波函数∣*υ，可以提取系统的任何信息*

回到伊辛模型、物理学和分子基态能量，中心任务是找到给定哈密顿量 *H* ( *不要与哈达玛门*混淆)的基态(最低能量本征态)!).

![$$ H\left|\left.\psi \right\rangle ={\lambda}_G\right|\left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equo.png)

(7.12)

其中*λ*T2*g*t5】为基态本征值，∣ *ψ* ⟩为本征态。研究基态给了我们关于系统低能性质的信息。一旦∣ *ψ* ⟩已知，就可以从波函数推导出物理性质。但方程 [7.12](#Equo) 中的挑战是，一般来说 *λ* <sub>*G*</sub> 的值和本征态都是未知数；因此，获得这些的估计是最重要的。状态的能量估计可以通过计算哈密顿量的期望值来获得。

![$$ \left\langle \psi \right|H\left|\left.\psi \right\rangle =E\right|\left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equp.png)

(7.13)

其中， *E* 为能量本征态。 *E* <sub>0</sub> 为基态。变分原理指出

![$$ \left\langle \psi \right|H\left|\left.\psi \right\rangle =E\right|\left.\psi \right\rangle \ge {E}_0 $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equq.png)

(7.14)

现在，哈密顿量 *H* 可以由任何埃尔米特矩阵的性质描述如下。

![$$ H=\sum \limits_{i=1}^N{\lambda}_i\mid \left.{\psi}_i\right\rangle \left\langle {\psi}_i\right| $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equr.png)

(7.15)

因此， *H* 的期望值可以表示为

![$$ \left\langle H\right\rangle =\left\langle \psi \right|H\mid \left.\psi \right\rangle =\left\langle \psi \right|\left(\sum \limits_{i=1}^N{\lambda}_i|\left.{\psi}_i\right\rangle \left\langle {\psi}_i\right|\right)\mid \left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equs.png)

![$$ =\sum \limits_{i=1}^N{\lambda}_i\left\langle \psi \right|\left.{\psi}_i\right\rangle \left\langle {\psi}_i\right|\left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equt.png)

![$$ =\sum \limits_{i=1}^N{\lambda}_i{\left|\left\langle {\psi}_i\right|\left.\psi \right\rangle \right|}^2 $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equu.png)

(7.16)

方程 [7.16](#Equu) 表示任何可观测状态的期望值都可以用与 *H* 相关的特征值作为权值的和来表示。并且，根据量子力学的假设，已知线性组合中的权重必须大于或等于零。这就是 VQE 算法的工作原理。

为了从计算的角度更深入地研究哈密顿量，哈密顿量可以用泡利算符的张量积之和(泡利项)来表示。

![$$ H=0.2\bullet X\otimes Y+0.8\bullet I\otimes Z+0.6\bullet I\otimes X $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equv.png)

![$$ =0.2\bullet XY+0.8\bullet IZ+0.6\bullet IX $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equw.png)

(7.17)

其中，泡利算符以其标准形式表示。

给定方程 [7.17](#Equw) 的哈密顿量和状态∣ *ψ* ⟩，VQE 中的目标是测量 *H* 的期望值

![$$ \left\langle \psi \right|H\left|\left.\psi \right\rangle =\left\langle H\right\rangle =0.2\bullet \left\langle \psi \right| XY\right|\left.\psi \right\rangle +0.8\bullet \left\langle \psi \right| IZ\left|\left.\psi \right\rangle +0.6\bullet \left\langle \psi \right| IX\right|\left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equx.png)

(7.18)

从方程 [7.18](#Equx) 可以推测，VQE 算法为每个泡利项构建一个量子电路，并计算相应泡利项的期望值。然后，算法将所有计算出的泡利项的期望值相加，得到 *H* 的期望值。该算法针对不同的试验波函数(ansatz 状态)重复运行估计 *H* 的期望值的例程。

状态准备电路的参数由经典计算机控制。在每一步中，经典计算机通过使用一些优化方法来改变参数，以创建具有比之前的 ansatz 状态更小的期望值的 ansatz 状态。这个过程允许经典计算机和量子计算机一起工作，以实现算法的目标，即找到基态能量。这就是为什么 VQE 是一个混合经典量子算法。

现在我们已经看了 VQE 的理论和实践，探索不同格式的 VQE 的例子是很好的，因为 VQE 是量子机器学习中最重要的概念之一。

#### VQE 与 Qiskit

在这个例子中，任务是使用变分量子本征解算器方法(VQE)确定矩阵 *M* 的最低本征值，其中

![$$ M=\left[\begin{array}{cccc}0&amp; \kern0.75em 0&amp; \kern0.75em 0&amp; \kern0.5em 0\\ {}0&amp; -1&amp; \kern0.75em 1&amp; \kern0.5em 0\\ {}0&amp; \kern0.75em 1&amp; -1&amp; \kern0.5em 0\\ {}0&amp; \kern0.75em 0&amp; \kern0.75em 0&amp; \kern0.5em 0\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equy.png)

作为第 [1](1.html) 章的总结，泡利矩阵由下式给出

![$$ X\equiv {\sigma}_1\equiv {\sigma}_x\equiv \left[\begin{array}{cc}0&amp; 1\\ {}1&amp; 0\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq15.png)；![$$ Y\equiv {\sigma}_2\equiv {\sigma}_y\equiv \left[\begin{array}{cc}0&amp; -i\\ {}i&amp; 0\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq16.png)；![$$ Z\equiv {\sigma}_3\equiv {\sigma}_z\equiv \left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq17.png)

两个量子位的向量可以表示为

![$$ v\left[\begin{array}{c}\ a\\ {}\ b\\ {}\ c\\ {}\ d\end{array}\ \right]=a\left|\left.00\right\rangle +b\right|\left.01\right\rangle +c\mid \left.10\right\rangle +d\mid \left.11\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equz.png)

作为第一步，矩阵 *M* 被分解成两个量子比特算子的和。

![$$ M=\alpha \left({X}_1\otimes {X}_2\right)+\beta \left({Y}_1\otimes {Y}_2\right)+\gamma \left({Z}_1\otimes {Z}_2\right)+\lambda \left({I}_1\otimes {I}_2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equaa.png)

(7.19)

其中⊗表示张量积， *α* ， *β* ， *γ* ， *λ* 是未知系数， *I* 是单位泡利矩阵，下标 1，2 表示算符作用的特定量子位。使用张量积的矩阵表示来解决这种分解。

为了形象化这种表示，在清单 [7-2a](#PC10) 中为`VQE_qiskit.ipynb` Jupyter 笔记本文件定义了泡利矩阵、 *𝑋* 、 *𝑌* 、 *Z* ，以及常见的库调用。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figc_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figc_HTML.jpg)

```
from qiskit import *
import numpy as np
# Define the Pauli matrices
X = np.array([[0,1],[1,0]])
Y = np.array([[0,-np.complex(0,1)],[np.complex(0,1),0]])
Z = np.array([[1,0],[0,-1]])

Listing 7-2aLibraries and Pauli Matrices for VQE_qiskit.ipynb

```

下一步，我们创建这些运算符的张量积，如清单 [7-2b](#PC11) 所示。

```
# Compute the tensor product of the Pauli matrices
XX = np.kron(X,X)
YY = np.real(np.kron(Y,Y)) # This will be a real matrix
ZZ = np.kron(Z,Z)
II = np.identity(4)
print("The XX gate is: \n{} \n".format(XX))
print("The YY gate is: \n{} \n".format(YY))
print("The ZZ gate is: \n{} \n".format(ZZ))

Listing 7-2bLibraries and Pauli Matrices for VQE_qiskit.ipynb

```

清单 [7-2b](#PC11) 给出了下面的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figd_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figd_HTML.jpg)

清单 [7-2c](#PC12) 验证我们通过*检验*所知道的；也就是说， *M* 可以分解成以下两个量子比特算符的和。

![$$ M=\frac{1}{2}\left({X}_1\otimes {X}_2+{Y}_1\otimes {Y}_2+{Z}_1\otimes {Z}_2-{I}_1\otimes {I}_2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equab.png)

(7.20)

```
# This is the decomposition of the "M" matrix
M = (XX+YY+ZZ-II)/2
print('M = \n',M)
print('')

Listing 7-2cDecomposition of M in VQE_qiskit.ipynb

```

反过来，它给我们一个确认作为输出，这是矩阵 *M* 。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fige_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fige_HTML.jpg)

##### 计算算子的期望值

随着 *M* 的分解到位，是时候利用*变分定理*确定 *M* 的*最低特征值*上的界了。为了完成这个任务，我们需要知道 *M* 对于不同试探波函数的期望值。我们从量子力学的基础知识中知道，算符𝑀对基态波函数∣ *ψ* ( *θ* )⟩的期望值具有如下形式。

![$$ E\left(\theta \right)=\left\langle \psi \left(\theta \right)|M|\psi \left(\theta \right)\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equac.png)

其中 *E* ( *θ* )是矩阵 *M* 的期望值。∣ *ψ* ( *θ* )⟩是由角度 *θ* 参数化的变分波函数。

其中最简单的可计算期望值是*z*T2】1⊗*z*T6】2 算子。当作用于∣ *ϕ* ⟩ = ( *a* ， *b* ， *c* ， *d* )给定的状态，使得⟨ *ϕ* | *ϕ* ⟩ = 1 时，期望值由下式给出

![$$ \left\langle \phi |{Z}_1\otimes {Z}_2|\phi \right\rangle ={a}^2+{d}^2-\left({b}^2+{c}^2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equad.png)

项 *a* <sup>2</sup> 和 *d* <sup>2</sup> 分别对应于状态∣00⟩和∣11⟩的概率，而 *b* <sup>2</sup> 和 *c* <sup>2</sup> 是状态∣01⟩和∣10⟩.的概率

为了制定模拟，按如下方式计算*概率*。

![$$ \left\langle \phi |{Z}_1\otimes {Z}_2|\phi \right\rangle =\frac{Number\ of\mid \left.00\right\rangle \kern0.5em or\mid \left.11\right\rangle states- Number\ of\mid \left.01\right\rangle \kern0.5em or\mid \left.10\right\rangle states}{Number\ of\ trials} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equae.png)

从分解试验中取出一片叶子来确定试验状态的其他算符的期望值，我们寻求将所有两个量子比特的算符分解成以下形式。

![$$ Q={U}^{\dagger}\left({Z}_1\otimes {Z}_2\right)U $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equaf.png)

其中 *U* 是特定于 *Q* 的酉矩阵。以下分解与该任务相关。

![$$ {X}_1\otimes {X}_2={\left({H}_1\otimes {H}_2\right)}^{\dagger}\left({Z}_1\otimes {Z}_2\right)\left({H}_1\otimes {H}_2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equag.png)

(7.21)

![$$ {Y}_1\otimes {Y}_2={\left({H}_1{S_1}^{\dagger}\otimes {H}_2{S_2}^{\dagger}\right)}^{\dagger}\left({Z}_1\otimes {Z}_2\right)\left({H}_1{S_1}^{\dagger}\otimes {H}_2{S_2}^{\dagger}\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equah.png)

(7.22)

其中 *H* 是哈达玛门，并且

![$$ {S}^{\dagger }=\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; -i\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equai.png)

等式 [7.20](#Equab) 、 [7.21](#Equag) 、 [7.22](#Equah) 允许我们将原矩阵 *M* 写成算子之和，如下。

![$$ M=\frac{1}{2}{\left({H}_1\otimes {H}_2\right)}^{\dagger}\left({Z}_1\otimes {Z}_2\right)\left({H}_1\otimes {H}_2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equaj.png)

![$$ +\frac{1}{2}{\left({H}_1{S_1}^{\dagger}\otimes {H}_2{S_2}^{\dagger}\right)}^{\dagger}\left({Z}_1\otimes {Z}_2\right)\left({H}_1{S_1}^{\dagger}\otimes {H}_2{S_2}^{\dagger}\right)+\frac{1}{2}\left({I}_1\otimes {I}_2\right)-\frac{1}{2}\left({Z}_1\otimes {Z}_2\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equak.png)

根据这些恒等式，矩阵 *M* 的期望值被给出为

![$$ \left\langle \psi |M|\psi \right\rangle =\frac{1}{2}\left[\left\langle \phi |\left({Z}_1\otimes {Z}_2\right)|\phi \right\rangle +\left\langle \varphi |\left({Z}_1\otimes {Z}_2\right)|\varphi \right\rangle +\left\langle \psi |\left({Z}_1\otimes {Z}_2\right)|\psi \right\rangle -1\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equal.png)

新的进化状态在哪里

![$$ \mid \left.\phi \right\rangle =\left({H}_1\otimes {H}_2\right)\mid \left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equam.png)

和

![$$ \mid \left.\varphi \right\rangle =\left({H}_1{S_1}^{\dagger}\otimes {H}_2{S_2}^{\dagger}\right)\mid \left.\psi \right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equan.png)

##### VQE 的 Ansatz

在计算出矩阵 *M* 的期望值后，下一步是定义一个*试探波函数*作为 ansatz。

![$$ \mid \left.\Psi \left(\theta \right)\right\rangle =\left(I\otimes X\right) CX\left[{R}_Z\left(\theta \right)\otimes I\right]\left(H\otimes I\right)\mid \left.00\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equao.png)

清单 [7-2d](#PC13) 给出了 ansatz 电路的可视化。

```
# Visualize Ansatz-circuit
theta=np.pi
q = QuantumRegister(2)
c = ClassicalRegister(2)
circuit = QuantumCircuit(q,c)
circuit.h(q[0])
circuit.rz(theta,q[0])
circuit.cx(q[0],q[1])
circuit.x(q[1])
circuit.barrier()
circuit.draw()

Listing 7-2dAnsatz Circuit Visualization VQE_qiskit.ipynb

```

这个代码片段给出了下面的输出，作为我们的 ansatz 电路。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figf_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figf_HTML.jpg)

清单 [7-2e](#PC14) 定义了一些函数，方便我们对 *M* 的期望值进行评估(如注释中所述)。

```
def anzatz(circuit,q,c,theta):
    '''
    The Anzatz wave function
    |psi > = (I X)(CX)(Rz(theta) I)(H I)|00>
    '''
    circuit.h(q[0])
    circuit.rz(theta,q[0])
    circuit.cx(q[0],q[1])
    circuit.x(q[1])
    circuit.barrier()

    return circuit

def measure_ZZ(circuit,N_shots=2**10,simulator_backend='qasm_simulator'):
    '''
    Measures the expectation value of ZZ on the 2-qubit states
    <ZZ> = the number of ( 00 )  and (11) states, minus the number of (01) and (10) states
    normalized over the number of trials
    '''
    simulator = Aer.get_backend(simulator_backend)
    result = execute(circuit,backend=simulator,shots=N_shots).result()

    items =result.get_counts().items()

    s = 0
    for key, counts in items:
        s+= (-1)**(int(key[0])+int(key[1]))*counts
    s = s/N_shots

    return s

def hamiltonian(theta,N_shots=2**10):
    '''
    The hamiltonian for the problem that corresponds
    to our matrix M:
    M = (1/2)*(XX+YY+ZZ-II)
    The hamiltonian is computed by separating it into three components
    according to the discussions in the previous cells.
    '''
    q = QuantumRegister(2)
    c = ClassicalRegister(2)

    ## 0.5*XX component
    circuit_xx = QuantumCircuit(q,c)
    circuit_xx = anzatz(circuit_xx,q,c,theta)
    circuit_xx.h(q[0])
    circuit_xx.h(q[1])
    circuit_xx.measure(q,c)
    E_XX = 0.5*measure_ZZ(circuit_xx,N_shots=N_shots)

    ## 0.5*YY component
    circuit_yy = QuantumCircuit(q,c)
    circuit_yy = anzatz(circuit_yy,q,c,theta)
    circuit_yy.sdg(q[0])
    circuit_yy.h(q[0])
    circuit_yy.sdg(q[1])
    circuit_yy.h(q[1])
    circuit_yy.measure(q,c)
    E_YY= 0.5*measure_ZZ(circuit_yy,N_shots=N_shots)

        # 0.5*ZZ component
    circuit_zz = QuantumCircuit(q,c)
    circuit_zz = anzatz(circuit_zz,q,c,theta)
    circuit_zz.measure(q,c)
    E_ZZ = 0.5*measure_ZZ(circuit_zz,N_shots=N_shots)

    # The - 1/2 comes from the fact that <psi|II|psi> = 1
    # it is always a constant

    return (E_XX+E_YY+E_ZZ-0.5)

Listing 7-2eFunction Definition VQE_qiskit.ipynb

```

量子电路模拟在下一步运行，如清单 [7-2f](#PC15) 所示。

```
# Generate several thetas, and find the best set of parameters
import matplotlib.pyplot as plt
# The number of trials to run
N_shots = 2**10

# Generate theta grid
theta = np.linspace(0.0,2*np.pi,200)
E = np.zeros(len(theta))

# Calculate the expectation value of the Hamiltonian for different theta
for k in range(len(theta)):
    E[k] =  hamiltonian(theta=theta[k],N_shots=N_shots)

# Plot the results
plt.title('Expectation value vs Angle',fontsize=15)
plt.ylabel('Expectation value of H',fontsize=15)
plt.xlabel('Theta (radians)',fontsize=15)
plt.plot(theta,E,label='Number of shots: {}'.format(N_shots))
plt.legend()
plt.show()

# Determine the lowest bound from varying theta
print('='*100)
print('The minimum bound on the lowest eigenvalue of M is E0={},\n'.format(min(E)))
print('The parameter that corresponds to this energy is theta={:0.2f} Rads'.format(theta[np.argmin(E)]))
print('='*100)

Listing 7-2fMinimum Expectation Value of M VQE_qiskit.ipynb

```

这个代码片段给出了下面的输出作为我们的期望值。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figg_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Figg_HTML.png)

输出中哈密顿量的最小能量的最小值出现在波函数 ansatz 中大约 *θ* = *π* 处，以 2 作为期望值的下限。能量以任意单位表示。

现在发现 *M* 的最小特征值的下界为*E*0 = 2.0，可以直接计算最小特征值来验证我们的解。

```
w, v = np.linalg.eig(M)

print('='*100)
print('Minimum eigenvalue using classical computer: Lambda={:0.2f}'.format(min(w)))
print('The minimum bound of the Eigenvalue from the quantum computing simulations is E={:0.2f}'.format(min(E)))
print('='*100)

Listing 7-2gAnsatz Circuit Visualization VQE_qiskit.ipynb

```

列表 [7-2g](#PC16) 给出了以下输出，验证了量子电路的下限与矩阵的最低特征值一致。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figh_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figh_HTML.jpg)

#### VQE 与谷歌 Cirq

谷歌的 Cirq 根据佩鲁佐等人(2014 年)[121]和韦克尔等人(2015 年)[147]的研究，提供了一个关于 VQE 实施的综合教程。

教程中的变分算法试图通过以下三个步骤获得给定 ansatz 状态的目标函数值。

1.  准备 ansatz 状态。

2.  进行测量，从哈密顿量中的一些项中取样。

3.  转到 1。

他们还指出了一个重要的方面，即在没有*量子相位估计*的情况下，你不能总是*直接测量*哈密顿量(参见第 [6 章](6.html))。因此，人们通常依赖期望值的线性来测量步骤 2 中的部分哈密顿量。人们总是需要重复测量来获得期望值的估计值。

本教程展示了您可以使用量子计算机来获得 ansatz 的目标函数的估计。然后可以在外部循环中使用它来获得目标函数的最低值的参数。对于这些值，您可以使用最佳的 ansatz 来产生问题的解决方案的样本，这获得了目标函数的最低可能值的一个有希望的良好近似。本教程在[`https://quantumai.google/cirq/tutorials/variational_algorithm`](https://quantumai.google/cirq/tutorials/variational_algorithm)【148】完整代码完成。强烈建议您访问此页面，并尝试 Cirq 中的 VQE 实施示例。

为了方便阅读本教程的材料，经 Google 许可，相关的开源 Jupyter 笔记本代码【148】已经作为`variational_algorithm_Cirq.ipynb`包含在本章中。

#### VQE 与里盖蒂森林

本章前面讨论了 Qiskit 中的 VQE 编程。鉴于 VQE 在量子机器学习和分子建模中的重要性，了解其他平台如何实现它是有帮助的。我们首先看一个类似于 Qiskit 练习的 VQE 的 Rigetti 森林实现，然后看一个利用 VQE 的分子建模练习。随着本书的深入，我们将 VQE 用于各种平台相关的各种 QML 应用程序和库。

首先，我们在森林虚拟环境中打开三个终端，就像我们在第 [5](5.html) 章中所做的一样。我们在服务器模式下启动 QVM，在服务器模式下启动 Quilc，在 Jupyter notebook 中使用以下命令，每个命令都在各自的终端中。

*   qvm:t0]

*   quic:t0]

*   Jupyter 笔记本:`jupyter notebook`。选择 Python 3 来创建一个新的笔记本实例。

让我们先来看一个使用 Forest 的基本 VQE 实现。为了运行一些优化任务，我们需要导入 Rigetti 的 Grove 库。

像往常一样，我们首先导入所需的库，用 Pauli Z-gate 定义一个矩阵，并定义一个 ansatz，如清单[7-3a`VQE_pyquil.ipynb`的](#PC17)所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figi_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figi_HTML.jpg)

```
# Variational-Quantum-Eigensolver
import numpy as np
from scipy.optimize import minimize
from pyquil.api import QVMConnection
import pyquil.api as api
from pyquil.gates import *
from pyquil import Program, get_qc
from grove.pyvqe.vqe import VQE

# Create connection with QVM
qvm = QVMConnection()
qc = get_qc('2q-qvm')

# Define a matrix
from pyquil.paulis import sZ
H = sZ(0)
# Define an ansatz
from pyquil.gates import RY
def ansatz(params):
    return Program(RY(params[0], 0))

Listing 7-3aAnsatz Circuit Visualization VQE_pyquil.ipynb

```

在下一步中，我们定义了用于计算期望值的函数，与我们在 Qiskit 中为我们的试验 ansatz 定义的 10，000 个测量值相同。这显示在清单 [7-3b](#PC18) 中。

```
# Function calculating expectation value
def expectation(params):
    # Define number of measurements
    samples = 10000
    # Define program
    prog = ansatz(params)
    # Measure
    ro = prog.declare('ro', 'BIT', 1) # Classical registry storing the results
    prog.measure(0, ro[0])
    # Compile and execute
    prog.wrap_in_numshots_loop(samples)
    prog_exec = qc.compile(prog)
    ret = qc.run(prog_exec)
    # Calculate expectation
    freq_is_0 = [trial[0] for trial in ret].count(0) / samples
    freq_is_1 = [trial[0] for trial in ret].count(1) / samples
    return freq_is_0 - freq_is_1

# Test of expectation value function
test = expectation([0.0])
print(test)

Listing 7-3bFunctions VQE_pyquil.ipynb

```

清单 [7-3b](#PC18) 生成 1.0 作为输出，证实了我们的估计。

列表 [7-3c](#PC19) ，绘制了期望值与参数值(即 *θ* 的值)的 VQE 图。

```
# Draw expectation alue against parameter value
params_range = np.linspace(0.0, 2 * np.pi, 25)
data = [expectation([params]) for params in params_range]
import matplotlib.pyplot as plt
plt.xlabel('Parameter value (Thetas)')
plt.ylabel('Expectation value')
plt.plot(params_range, data)
plt.show()

Listing 7-3cPlot the VQE curve VQE_pyquil.ipynb

```

我们得到下面的输出，它与 Qiskit 的情况非常相似。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figj_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Figj_HTML.png)

输出中哈密顿量的最小能量的最小值出现在波函数 ansatz 中的 *θ* = *π* 处，以 1 作为期望值的下限。能量以任意单位表示。

正如在 VQE 的两个例子(Qiskit 和 Forest)中所看到的，可以根据参数计算的期望值的数量是有实际限制的。需要更多参数值的大得多的哈密顿量的期望值的计算是一个挑战。这可以通过使用优化算法来解决。例如，可以通过 SciPy optimize 包应用 Nelder-Mead [149]优化算法，如清单 [7-3d](#PC20) 所示。

```
# Eigenvalue Optimization
initial_params = [0.0]
minimum = minimize(expectation, initial_params, method='Nelder-Mead',
                   options={'initial_simplex': np.array([[0.0], [0.05]]), 'xatol': 1.0e-2})
print(minimum)

Listing 7-3dNelder-Mead Optimization VQE_pyquil.ipynb

```

内尔德-米德 <sup>[6](#Fn6)</sup> 方法【149】用*单工*操作。单纯形在二维是三角形，在三维是四面体。维基百科页面说明了单纯形如何移向最小值；它不断改变它的大小和形状，在接近最小值时变得更小。如果满足两个条件，则搜索成功。

*   单纯形的*大小*最多为`xatol`，是 SciPy 库的一部分。它根据*绝对误差*定义了结果的*精度*。例如，如果 xatol 为 0.01，并且该方法返回最小值的位置为[1.33，2.56]，则有希望(但不确定)实际最小值*的坐标在 1.32–1.34 和 2.55–2.57 之间。*

*   单纯形顶点处的函数值差最多为`fatol`。

这意味着单纯形变得更小，而目标函数值在其顶点几乎保持不变。

清单 [7-3d](#PC20) 给出了下面的输出，其中`fun`是最小特征值。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figk_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figk_HTML.jpg)

到目前为止，我们已经处理了无噪声 QVM 公式。Rigetti Forest 还提供了向模拟中添加噪声的选项。因为 VQE 算法旨在用于近期的量子计算平台，所以考虑使用特定噪声模型的 QVM 运行是有帮助的。清单 [7-3e](#PC21) 是在 pyQuil 中设置吵闹的 QVM 的代码片段。

```
pauli_channel = [0.1, 0.1, 0.1] #10% chance of each gate at each timestep
noisy_qvm = api.QVMConnection(gate_noise=pauli_channel)

#Verify Simulator is indeed noisy
p = Program(X(0), MEASURE(0, 1))
noisy_qvm.run(p, [0, 1], 10)

Listing 7-3eNoisy-QVM VQE_pyquil.ipynb

```

清单 [7-3e](#PC21) 介绍了每个门在每个时间戳有 10%的机会。测量∣0⟩状态的代码输出示例显示了正在测量的位 0，这表明 QVM 模拟器确实有噪声。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figl_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figl_HTML.jpg)

通过在角度 *θ* 和期望值的范围内运行`for`循环，可以生成噪声 VQE 的曲线图。要实现这一点，必须使用以下命令将 Forest 的`grove`库安装在与 QVM 和 Quilc 相同的目录中。

```
$ pip install quantum-grove

```

安装命令和初始输出如下面的屏幕截图所示，其中,`grove`库被安装在一个名为`qml`的虚拟环境中。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figm_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figm_HTML.jpg)

实际一代的 VQE 情节与嘈杂的 QVM 是留给你作为一个练习。请参考 [`https://grove-docs.readthedocs.io/en/latest/vqe.html`](https://grove-docs.readthedocs.io/en/latest/vqe.html) 处的 Grove 文档。

##### 分子系统的 VQE

作为展示 VQE 型算法实际价值的一个快速示例，下面是一个获得分子系统最低能量状态的精确近似值的练习。提高运行这种算法的效率的能力对药物和药物开发以及材料工程方法的改进具有直接的积极影响。

本代码改编自 [`https://grove-docs.readthedocs.io/en/latest/vqe.html`](https://grove-docs.readthedocs.io/en/latest/vqe.html) 的 Grove 文档。Grove 允许我们定义自己的哈密顿量，并使用 sigma Z 和 sigma Y 的泡利矩阵获得结果。列表 [7-3e](#PC21) 展示了哈密顿量的选择如何导致不同的测量结果。理论上，如果可以确定氢分子哈密顿量的泡利矩阵分解，那么我们就能够用适用于该分子的哈密顿量的组合来代替所用的哈密顿量。因此，要么可以生成参数变化的图形，并用肉眼发现结果，要么我们可以使用从 VQE 函数接收的数据尝试不同的最小化方法。

清单 [7-3f](#PC23) 给你一个 VQE 的味道，帮助解决一个真实世界的分子模拟练习，其中我们循环期望值 10，000 次。

```
# Molecular Systems Solutions
from pyquil.paulis import sY
initial_angle = [0.0]
#Hamiltonian is sigma Y
hamiltonian = sY(0)
vqe_inst = VQE(minimizer=minimize,
               minimizer_kwargs={'method': 'nelder-mead'})
#ansatz is rotation by X
def small_ansatz(params):
    return Program(RX(params[0], 0))
#looping from 0 to 2 pi
angle_range = np.linspace(0.0, 2 * np.pi, 20)
data = [vqe_inst.expectation(small_ansatz([angle]), hamiltonian, 10000, qvm)
        for angle in angle_range]

plt.xlabel('Angle [radians]')
plt.ylabel('Expectation value')
plt.plot(angle_range, data)
plt.show()

Listing 7-3fMolecular System VQE_pyquil.ipynb

```

列表 [7-3f](#PC23) 生成以下曲线图，作为分子哈密顿量的期望值相对于参数 *θ* 变化的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fign_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fign_HTML.png)

总之，VQE 是一种混合量子经典算法[121],可以找到给定哈密顿量的最小特征值和相应的特征向量。该算法的主要应用之一是寻找分子的基态能量。目前，在 NISQ 时代，我们的量子计算能力仅限于处理非常嘈杂的量子位，因为它们没有有效地与环境隔离。这种限制为诸如 VQE 算法等利用小深度电路的算法提供了巨大的优势。

由于计算成本极高，模拟大型量子系统或求解大规模线性代数问题等应用对经典计算机来说极具挑战性。量子计算机有望开启这些应用，尽管容错量子计算机可能在几年内都不会出现。目前，量子设备有严重的限制，包括有限的量子位数量和限制电路深度的噪声过程。

分子模拟中的 VQE 实际上利用了量子计算机的特性，因为它是一种“近期”量子计算算法。这意味着它不依赖于数千个量子位、可靠且可扩展的纠错、长的相干时间或大的电路深度。这些算法类型具有很高的潜力来提高运行在量子平台上的应用程序的效率。

#### QAOA

量子交替算子 Ansatz(QAOA)——也称为量子近似优化算法——最初由 Farhi 等人[69]在 2014 年提出，用于获得组合优化问题的近似解。后来，它被概括为一个独立的 ansatz [124]，被证明是计算通用的[125]。QAOA 是 VQE 算法家族中最重要的例子之一。

QAOA 是量子计算机的一种浅回路变分算法，受量子退火的启发。量子系统的演化受薛定谔方程![$$ i\mathit{\hslash}\frac{d\mid \psi (t)\Big\rangle }{dt}=H\mid \psi (t)\Big\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq18.png)支配；∣*ψ*(*t*)⟩=*e*T7*iht*/∣0⟩(其中ℏ是约化普朗克常数)描述了一个系统在应用哈密顿量 *H* 一段时间 *t* 后所处的状态。给定这些条件，*哈密顿仿真*输出一系列计算门，这些计算门实现了酉*U*=*e*<sup>-*iHt*</sup>，为了便于计算，我们在适当的单位中取= 1。

总哈密顿量是厄米算符，通常是大量单个哈密顿量的总和。作为一个例子，哈密顿量 *H* 可以等于(*H*<sub>1</sub>+*H*<sub>2</sub>)，这又可以使用 *Lie 乘积公式* <sup>[7](#Fn7)</sup> 表示如下。

![$$ {e}^{-i\left({H}_1+{H}_2\right)/t}=\underset{n\to \infty }{\lim }{\left({e}^{-{iH}_1t/n}{e}^{-i{H}_2t/n}\right)}^n $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equap.png)

(7.23)

由于方程 [7.23](#Equap) 的极限是无穷大，所以在量子计算机上实现这个公式时需要对级数进行截断。截断程序在模拟中引入误差，该误差可由最大模拟误差 *ϵ* 限定，该误差由以下条件定义

![$$ \epsilon &gt;\left\Vert {e}^{- iHt}-U\right\Vert $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equaq.png)

这个截断的过程如图 [7-9](#Fig9) 所示，被称为*截断*。它被广泛用于在量子计算机上模拟非交换哈密顿量。通用的三值化公式如下所示

![$$ {e}^{- iHt}={\left({e}^{-{iH}_ot/n}{e}^{-i{H}_1t/n}\dots {e}^{-i{H}_ct/n}\right)}^n+O\left( some\ polynomials\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equar.png)

(7.24)

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig9_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig9_HTML.jpg)

图 7-9

Trotterization 来源[122]

用一个简单的例子就可以说明 Trotterization 和方程 [7.20](#Equab) 的重要性。假设我们想要模拟一个哈密顿量*H*=*X*<sub>0</sub>+*Z*<sub>0</sub>，其中 *X* 和 *Z* 是泡利矩阵，下标是应用哈密顿量的量子位的标签。在这种情况下，不可能单独模拟每个哈密顿量*，因为泡利门 *X* 和 *Z* 不交换。在这种情况下，通过在短时间内在*X*T24】0 和*Z*T28】0 之间反复切换来进化整个哈密顿量。*

 *在 QAOA 框架中，绝热路径被离散在一些 *p* 步骤中，其中 *p* 是精度的度量，并且每个离散时间步骤 *l* 具有两个参数: *β* <sub>*l*</sub> 和 *γ* <sub>*l*</sub> 。和一般的 VQE 一样，经典的变分算法在量子硬件运行结束时，根据观察到的能量来优化这些参数。因此，QAOA 可以被解释为一个*Trotterized*绝热变换，其中 troterized 的阶数 *p* 决定了解的精度。

QAOA 算法的目标是通过顺序应用问题酉![$$ {U}_p={e}^{-i{H}_p{\beta}_l} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq19.png)和混合器酉![$$ {U}_m={e}^{-i{H}_m{\gamma}_i} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq20.png)【127】将输入状态∣*ψ*T2】0⟩映射到给定问题的基态，哈密顿量 *H* <sub> *p* 。这给出了下面的 ansatz，它是方程 [7.10](#Equl) 和 [7.11](#Equm) 的形式的*。*</sub>

![$$ U\left(\beta, \gamma \right)=\prod \limits_{l=1}^p{e}^{-i{H}_p{\beta}_l}{e}^{-i{H}_m{\gamma}_i} $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equas.png)

(7.25)

在哪里，

![$$ \theta =\left(\beta, \gamma \right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equat.png)

从根本上说，期望的动作是在绝热条件下离散化(即单独分离和区分)由*H*(*t*)=(1-T6】t)*H*<sub>0</sub>+*tH*<sub>1</sub>给出的*时间相关的*哈密顿量。这是通过*旋转*单元来实现的。例如，对于时间步长 *t* <sub>0</sub> ，酉可以拆分为*U*(*t*<sub>0</sub>)=*U*(*H*<sub>0</sub>，*β*<sub>0</sub>)*U*(*H*<sub>1)我们可以在随后的时间步骤中继续这样做，最终将进化分割成这样的块。</sub>

![$$ U=U\left({H}_0,{\beta}_0\right)U\left({H}_1{\gamma}_0\right)\dots U\left({H}_0,{\beta}_p\right)U\left({H}_1{\gamma}_p\right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equau.png)

(7.26)

哈密顿量 *H* <sub>0</sub> 称为*驱动或混合*哈密顿量， *H* <sub>1</sub> 称为*成本*哈密顿量。最简单的混合哈密顿量由![$$ {H}_0=-\sum \limits_i{\sigma}_i^x $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq21.png)给出。通过在两个哈密尔顿函数之间交替，混合哈密尔顿函数驱动状态朝向相等的叠加，而代价哈密尔顿函数试图找到它自己的基态。在优化参数的最后，离散化的演化产生绝热路径的近似。

请注意，由于哈密顿量中的多体项和有限的器件连接性，将单位分解成本征门可能会导致更长深度的电路。然而，QAOA 的优势之一是某些问题的可行子空间小于完整的希尔伯特空间，这种限制可能导致更好的执行算法。

##### Rigetti Forest 的实践 QAOA

现在我们已经了解了 QAOA 的理论方法，最好有一个实际的动手方法。我们与里盖蒂森林和 QVM 合作。和以前一样，我们在服务器模式下启动 QVM 和 Quilc，并在各自的终端中使用以下命令启动 Jupyter 笔记本。

像往常一样，我们首先导入所需的库，用泡利 Z 门定义一个矩阵，并定义量子位的数量，如清单[7-4a`QAOA_pyquil.ipynb`的](#PC24)所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figo_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figo_HTML.jpg)

```
#Libraries
import numpy as np
from functools import partial
from pyquil import Program, api
from pyquil.paulis import PauliSum, PauliTerm, exponential_map, sZ
from pyquil.gates import *
from pyquil import Program, get_qc
from pyquil.api import ForestConnection
from pyquil.api import WavefunctionSimulator
from pyquil.api import QVMConnection
from scipy.optimize import minimize
np.set_printoptions(precision=3, suppress=True)
qvm = QVMConnection()

# Number of qubits
n_qubits = 2

Listing 7-4aLibraries and Qubits QAOA_pyquil.ipynb

```

接下来，我们定义一些量子位上的混合哈密顿量。为了达到这个目的，我们使用 Pauli-X 算符，它的系数表示给定量子位的横向场强度。这个算符对所有的量子位都不起作用，除了给定的那个。下面是两个量子位上混合哈密顿量的定义。

```
Hm = [PauliTerm("X", i, 1.0) for i in range(n_qubits)]

Listing 7-4bLibraries and Qubits QAOA_pyquil.ipynb

```

作为一个例子，伊辛问题可以最小化。伊辛问题由成本哈密顿量![$$ {H}_C=-{\sigma}_1^Z\otimes {\sigma}_2^Z $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq22.png)定义，其最小值在![$$ {\sigma}_1^Z={\sigma}_2^Z $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq23.png)时达到。

```
J = np.array([[0,1],[0,0]]) # weight matrix of the Ising model. Only the coefficient (0,1) is non-zero.

Hc = []
for i in range(n_qubits):
    for j in range(n_qubits):
        Hc.append(PauliTerm("Z", i, -J[i, j]) * PauliTerm("Z", j, 1.0))

Listing 7-4cDefine Ising Problem QAOA_pyquil.ipynb

```

下一步，我们计算迭代的![$$ {e}^{-i{H}_m\gamma } $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq24.png)和![$$ {e}^{-i{H}_C\beta } $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq25.png)。为此，我们可以使用 pyQuil `exponential_map`函数来构建两个函数，这两个函数接受 *γ* 和 *β* 并返回![$$ {e}^{-i{H}_m\gamma } $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq26.png)和![$$ {e}^{-i{H}_C\beta } $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq27.png)。

```
exp_Hm = []
exp_Hc = []
for term in Hm:
    exp_Hm.append(exponential_map(term))
for term in Hc:
    exp_Hc.append(exponential_map(term))

Listing 7-4dDefine Ising Problem QAOA_pyquil.ipynb

```

然后，我们为 *p* 设置值，并初始化 *γ* <sub>*i*</sub> 和 *β* <sub>*i*</sub> 参数。

```
n_iter = 10 # number of iterations of the optimization procedure
p = 1
β = np.random.uniform(0, np.pi*2, p)
γ = np.random.uniform(0, np.pi*2, p)

Listing 7-4eInitializing Values QAOA_pyquil.ipynb

```

初始状态是所有状态∣*q*T2】1T4】qT6】2…*q*<sub>*n*</sub>⟩的均匀叠加，并且可以在∣0⟩.状态的所有初始量子位上使用哈达玛门来创建

```
initial_state = Program()
for i in range(n_qubits):
    initial_state += H(i)

Listing 7-4fInitializing Values QAOA_pyquil.ipynb

```

接下来，我们通过组合由函数`evolve`给出的不同酉矩阵来创建电路。

```
def create_circuit(β, γ):
    circuit = Program()
    circuit += initial_state
    for i in range(p):
        for term_exp_Hc in exp_Hc:
            circuit += term_exp_Hc(-β[i])
        for term_exp_Hm in exp_Hm:
            circuit += term_exp_Hm(-γ[i])

    return circuit

Listing 7-4gCircuit Definition QAOA_pyquil.ipynb

```

接下来，创建一个`evaluate_circuit`函数，该函数采用由 *γ* 和 *β* 串联而成的单个向量`beta_gamma`，并返回⟨*ψ*|*h*|<sub>t11】ct13】|*ψ*⟩=*h*t18】ct21】|*ψ*⟩,where*ψ*</sub>

```
def evaluate_circuit(beta_gamma):
    β = beta_gamma[:p]
    γ = beta_gamma[p:]
    circuit = create_circuit(β, γ)
    return qvm.pauli_expectation(circuit, sum(Hc))

Listing 7-4hCircuit Evaluation QAOA_pyquil.ipynb

```

最后，我们优化角度。

```
result = minimize(evaluate_circuit, np.concatenate([β, γ]), method='L-BFGS-B')
result

Listing 7-4iOptimize Angles QAOA_pyquil.ipynb

```

这为我们提供了以下输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figp_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figp_HTML.jpg)

以下是对结果的解释。

使用找到的最佳参数创建电路。

```
circuit = create_circuit(result['x'][:p], result['x'][p:])

```

`statevector_simulator`后端，以显示电路创建的状态。

```
wf_sim = api.WavefunctionSimulator(connection=fc)
state = wf_sim.wavefunction(circuit)
print(state)

```

这给出了一个输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figq_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figq_HTML.jpg)

该输出显示状态大约为![$$ \left(0.5-0.5i\right)\left(\mid \left.00\right\rangle +\left|\left.11\right\rangle \right)={e}^{i\varphi}\frac{1}{\sqrt{2}}\right(\mid \left.00\right\rangle +\left|\left.11\right\rangle \right) $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq28.png)。这里， *φ* 是一个相位因子，它不影响概率。这个结果对应的是经典问题的两个解的一致叠加:( *σ* <sub> 1 </sub> = 1， *σ* <sub> 2 </sub> = 1)和(*σ*<sub>1</sub>= 1，*σ*<sub>2</sub>= 1)。最后，我们评估运算符![$$ {\sigma}_1^Z $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq29.png)和![$$ {\sigma}_2^Z $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq30.png)。

```
print(qvm.pauli_expectation(circuit, PauliSum([sZ(0)])))
print(qvm.pauli_expectation(circuit, PauliSum([sZ(1)])))

```

这为我们提供了以下输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figr_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figr_HTML.jpg)

输出显示两者都近似等于零，这是一个预期的结果，因为两个自旋状态都是-1 和 1/2 的时间。输出对应于典型的量子行为，其中

![$$ \mathrm{Expectation}\ \mathrm{of}\ \left({\sigma}_1^Z{\sigma}_2^Z\right)\ne \left[\mathrm{Expectation}\ \mathrm{of}\left({\sigma}_1^Z\right)\right]\ \left[\mathrm{Expectation}\ \mathrm{of}\left({\sigma}_2^Z\right)\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equav.png)

##### 曲波的 QAOA 解决方案

现在，我们来看一个用 QAOA 解决曲波问题的例子。近年来，量子粒子在解决离散组合优化任务方面受到了极大的关注，这些任务在物流行业中广泛存在。量子粒子也因为在近期量子硬件上易于实现而变得流行。

我们在本章前面看了一个计算曲波的例子。这个练习的重点是使用里盖蒂·QVM 和 SciPy 库解决同一个曲波问题。概括一下，下面是我们的优化问题的例子。

![$$ (\mathrm{minimize}) f=-5x-3y-8z-6w+4 xy+8 xz+2 yz+10 zw $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equ3.png)

其中变量 *x* 、 *y* 、 *z* 、 *w* 为二进制；也就是说，它们只能有值 0 和 1。为了解决曲波的优化问题，我们创建了如下矩阵形式的模型。

![$$ (\mathrm{minimize}) f=(xyzw)\left[\begin{array}{c}\begin{array}{cc}-5&amp; \kern0.5em 2\\ {}\kern0.75em 2&amp; -3\end{array}\\ {}\begin{array}{cc}\kern0.5em 4&amp; \kern0.75em 1\\ {}\kern0.5em 0&amp; \kern0.75em 0\end{array}\end{array}\kern1em \begin{array}{c}\begin{array}{cc}\kern0.75em 4&amp; \kern0.75em 0\\ {}\kern0.75em 1&amp; \kern0.75em 0\end{array}\\ {}\begin{array}{cc}-8&amp; \kern0.75em 5\\ {}\kern0.5em 5&amp; -6\end{array}\end{array}\right]\left[\begin{array}{c}x\\ {}y\\ {}z\\ {}w\end{array}\right] $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equ4.png)

Note

线性项的系数出现在矩阵的主对角线上。唯一的*约束*是将 0 或 1 限制为决策变量的值；否则，曲波就是一个不受约束的模特*。曲波的所有问题数据都包含在矩阵中。*

为了解决这个问题，我们开始导入一些库并定义与 QVM 的通信，如 Jupyter 笔记本格式的清单 [7-5a](#PC36) 。

```
# Import Libraries and communicate with QVM
import numpy as np
import matplotlib.pyplot as plt
from pyquil.paulis import PauliSum
from pyquil.api import WavefunctionSimulator
from pyquil.api import ForestConnection
from pyquil.api import QVMConnection
from scipy.optimize import minimize
from pyquil.unitary_tools import lifted_pauli
from scipy.optimize import minimize
np.set_printoptions(precision=3, suppress=True)
qvm = QVMConnection()

Listing 7-5aLibraries QUBO_pyquil.ipynb

```

接下来，我们使用`func_y`函数定义矩阵形式，使用另一个函数`num_2_bin`定义系数的二进制值映射。然后我们画出结果。

```
def func_y(config):
    matr = np.array([[-5, 2, 4, 0], [2, -3, 1, 0], [4, 1, -8, 5], [0, 0, 5, -6]])
    return config @ matr @ config

def num_2_bin(num):
    bin_str = np.binary_repr(num, width=4)
    bin_arr = np.array([int(x) for x in bin_str])
    return bin_arr

Listing 7-5bQUBO Solution QUBO_pyquil.ipynb

```

列表 [7-5b](#PC37) 为相应变量值的最小化 *f* 生成以下输出图。

图 [7-10](#Fig10) 显示了模型的解如下:*f*= 11；*x*=*w*= 1； *y* = *z* = 0。 *x* = 1， *y* = 0， *z* = 0， *w* = 1 为位串 1001；也就是数字 9 的二进制表示，其对应的函数值是*f*= 11。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig10_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig10_HTML.png)

图 7-10

曲波 QAOA 解决方案

## 监督学习:量子支持向量机

数据分类是最重要的机器学习工具之一，因为它可以识别、分组和研究与用例相关的新数据，这些用例多种多样，如计算机视觉问题、医学成像、药物发现、手写识别、地统计学和许多其他领域。在机器学习中，最常见的数据分类方法之一是支持向量机(SVM)。SVM 是一种监督学习方法，并且特别有用，因为它允许通过使用超平面来分离两个类别，从而将输入的训练数据集分类为两个类别之一。与超平面一起使用的支持向量本质上是用于最大化类之间距离的数据点。

第 [5](5.html) 和 [6](6.html) 章讨论了将经典数据映射到特征地图中。*量子支持向量机*(QS VM)使用特征映射将数据点映射到量子电路。qSVMs 是多项理论和实验研究的主题[129]。qSVMs 使用量子比特而不是经典比特来解决问题。许多 qsvm[130]、[131]、[132]和*量子启发的* SVM [133]算法在量子域中利用*内核技巧*。Havlicek 等人[135]发表了一篇关于 qSVM 和监督学习的优秀研究论文。

生成基于 qSVM 的练习需要以下条件。

1.  缩放、归一化和主成分分析

2.  生成核矩阵

3.  估计用于 QSVM 分类的一组新数据点(测试数据)的核

在 QSVM 分类阶段，*经典 SVM* 产生*分离超平面*而不是量子电路，这里量子计算机被使用了两次。在第一种情况下，为所有训练数据对估计核。第二次，为新的日期或测试数据估计内核。

在第 [2](2.html) 章所涵盖的经典 SVM 的延续中，我们考察了将知识转化到量子领域的要求。

*   要完成这个任务，首先要考虑的是如何将经典数据点 *x* 转化为量子数据点∣ *ψ* ( *x* )⟩.这可以通过创建包含 *ψ* ()的电路 *C* ( *ψ* ( *x* )来实现，其中 *ψ* 是应用于经典数据的任何经典函数。

*   接下来，用参数 *ϑ* 构建一个参数化的量子电路 *V* ( *ϑ* )来处理数据。

*   执行测量，为每个识别经典数据标签的经典输入 *x* 返回经典值-1 或+1。

*   最后，我们利用*量子变分电路* (QVC)的概念，为这个问题定义了一个形式为*v*(*ϑ*)*c*(*ψ*(*x*))∣0⟩.的 ansatz

Note

写这本书的时候，还没有确切的实验证据证明 QSVM 提供了明显的量子优势。然而，参考文献[135]的作者认为，如果我们使用特征映射会有优势，因为否则，我们就不需要量子计算机来构建内核。出于这个原因，也因为今天大多数库都为量子 SVM 提供了一个独特的内置函数，所以这里不探讨这方面的实际代码。如果您有兴趣尝试 qSVM 的实践代码，请参考 Qiskit 文档，网址为[`https://qiskit.org/documentation/tutorials/machine_learning/01_qsvm_classification.html`](https://qiskit.org/documentation/tutorials/machine_learning/01_qsvm_classification.html)【136】`.`

在写这本书的时候，建立用例来说明 qSVM 相对于经典 SVM 的优势是一个非常活跃的研究领域。例如，欧洲粒子物理研究所(CERN)大型强子对撞机(LHC)的研究人员正在积极工作，看看与他们的实验需求相关的巨大计算挑战是否可以在量子计算机的帮助下得到解决。为此，他们已经成功地将 qSVM 用于 ttH (H 到两个光子)，希格斯耦合到 LHC 的顶夸克分析[138]。

很多数据分析和机器学习技术都涉及到*优化*。为此，使用 D-Wave 处理器通过量子退火来解决组合优化问题多年来一直备受关注。

## D 波量子计算

D-Wave Systems 成立于 1999 年，生产利用量子退火的量子计算设备，量子退火已被用于执行深度量子学习协议超过十年。

今天存在的量子计算有不同的定义。常见的格式是利用门模型的量子计算。这是经典门模型的扩展，其中计算门应用于量子位寄存器，以执行由量子位组成的量子状态的任意转换。你熟悉经典计算中的门模型计算的基本方法。量子计算领域中的门模型是一种自然延伸。

另一个常见的范例是量子退火，通常被称为绝热量子计算，尽管存在细微的差异。量子退火通过使工程挑战相对容易地扩大规模来解决特定的问题。他们的最新系统 Advantage 在 2020 年拥有 5000 个超导量子位，相比之下，门模型量子计算机的超导量子位不到 100 个。D-Wave 十多年来一直在建造超导量子退火炉，该公司目前保持着量子比特数量的记录。

量子退火是 D-Wave 量子计算机所基于的计算模型，它通过将多体量子系统从一个容易表征的系统逐渐演化为一个难以表征的系统来工作。在这个模型中，有效的开放系统采样需要量子系统的快速演化。

图 [7-11](#Fig11) 说明了退火过程。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig11_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig11_HTML.png)

图 7-11

量子退火(改编自[137])

在退相干引发热化之前，当接近共振点时，量子态可以被隧穿。蓝色的阴影说明了能级的占有情况。在图 [7-11](#Fig11) 中，图 A 显示了量子态在热退火中必须穿越局部最小值的标准，而相干量子态在接近共振时可以隧穿。图 [7-11](#Fig11) 中的图 B 说明了相干效应通过与环境的相互作用而衰减，导致系统能级占有率的概率分布遵循吉布斯分布。

深度量子学习的一个本质特征是，它不需要大型通用量子计算机。量子退火器不是通用量子计算机(UQC)，但比任何 UQC 都更容易构建和升级(见图 7-11(T3)中的图表 A)。量子退火器非常适合实现深度量子学习器，早在 2011 年就已经通过 D-Wave 上市。D-Wave 量子退火器是一种可调谐的横向伊辛模型，可以通过编程产生经典系统和某些量子自旋系统的热态。

从硬件角度来看，D-Wave 实现了使用超导金属超导回路的通量量子位。这个金属环允许电流顺时针或逆时针流动，这就是信息在量子位上编码的方式。量子玻尔兹曼机器[139]，具有能够实现通用量子逻辑的更一般的可调耦合，目前处于设计阶段[140]。Biamonte 等人[140]的一项研究确立了非量子随机(也称为*非随机* ) D 波量子退火硬件的当代实验目标，该硬件可能能够实现通用量子玻尔兹曼机器。此外，片上硅波导与数百个可调干涉仪构成线性光学阵列。专用超导量子信息处理器可以用来实现量子近似优化算法。

D-Wave 计算平台的能力被 Google、NASA 和 Los Alamos 等许多公司用来解决问题。实现相干伊辛模型的 QNN 云也实现了量子光学。它的限制不同于超导架构。一些这样的研究和工业机构已经利用他们的量子系统平台产生了经过验证的优化和量子机器学习的好处。

D-Wave 已经通过 Leap quantum cloud service 为 38 个国家的用户提供了他们的量子计算服务(正如本书撰写时的情况)。用户可以浏览到 [`https://cloud.dwavesys.com/leap/`](https://cloud.dwavesys.com/leap/) ，请求获得他们现实生活中量子硬件上免费但有限的使用时间和资源。图 [7-12](#Fig12) 显示成功登录后的 D-Wave Leap 界面。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig12_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig12_HTML.png)

图 7-12

D-Wave Leap 网站 [`https://cloud.dwavesys.com/leap/`](https://cloud.dwavesys.com/leap/)

关于他们的系统和文件的更多信息可以在[`https://cloud.dwavesys.com/leap/resources`](https://cloud.dwavesys.com/leap/resources)【142】获得。库和示例代码可以在 GitHub 上的 Ocean SDK[`https://github.com/dwavesystems`](https://github.com/dwavesystems)【141】中获得。写这本书的时候，D-Wave ( [`www.dwavesys.com`](http://www.dwavesys.com) )上有超过 250 个用户开发的量子应用，包括航班调度、选举建模、量子化学模拟、汽车设计、预防性医疗保健、物流等等。

基本上，量子退火的工作原理是首先将一个问题编码到候选解的搜索空间中，其中最优解是需要最低能量的解。D-Wave 的处理器通过叠加同时遍历所有可能的解决方案，找到能量最低的解决方案，从而找到这个最佳解决方案。

### D 波量子退火系统的编程

当对 D-Wave 量子退火系统进行编程时，用户将一个问题映射为对“最低能量谷”的搜索，对应于最佳可能结果。量子处理单元同时考虑所有的可能性，以确定形成这些关系所需的最低能量。这些解是对应于所发现的量子位的最佳配置或能量分布中的最低点的值。这些值通过网络返回给用户程序(参考 D-Wave 网站[143])。因为量子计算机是概率性的，而不是确定性的，所以计算机会在很短的时间内返回许多非常好的答案——确切地说，一秒钟内会有数千个样本。这不仅提供了找到的最佳解决方案，还提供了可供选择的其他有效方案。D-Wave 的量子计算机对于解决最优化和 NP 难问题特别有用，例如*旅行售货员问题* (TSP)和 Max-Cut。

D-Wave 的开源 Ocean SDK ( [`https://github.com/dwavesystems/dwave-ocean-sdk`](https://github.com/dwavesystems/dwave-ocean-sdk) )，可在 GitHub 和 Leap ( [`www.dwavesys.com/take-leap`](http://www.dwavesys.com/take-leap) )上使用，有内置的算法模板，能够使用熟悉的编程语言 Python 开发新代码，有助于应用程序开发。图 [7-13](#Fig13) 展示了 D-Wave 量子计算平台的整体架构及其 Ocean 软件堆栈。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig13_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig13_HTML.png)

图 7-13

D-Wave 平台和海洋软件栈(来源[143])

该程序是根据一个具有如下一般结构的数学表达式建模的(参考 D-Wave 文档[141]，[142])。

![$$ Obj\left({a}_i,{b}_{ij};{q}_i\right)=\sum \limits_i{a}_i{q}_i+\sum \limits_{ij}{b}_{ij}{q}_i{q}_j $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equaw.png)

(7.27)

用于定义编程模型([141]、[142])的方程 [7.27](#Equaw) 的组成部分在表 [7-1](#Tab1) 中列出。

表 7-1

程序设计模型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

*q*<sub>T3】IT5】</sub>

 | 

量子位

 | 

参与退火循环并进入两种可能的最终状态之一的量子位:{0，1}

 |
| --- | --- | --- |
| *q*<sub>T3】IT5】T6】qT8】T9】jT11】</sub> | 耦合器 | 允许一个量子位影响另一个量子位的物理设备。 |
| *一个* <sub>一个*我*一个</sub> | 重量 | 与程序员控制的每个量子位相关联的一个实值常数。它影响量子位坍缩成两种可能的最终状态的趋势。 |
| *b*<sub>T3】ijT5】</sub> | 力量 | 与编程器控制的每个耦合器相关的一个实值常数。它控制一个量子位对另一个量子位的影响。 |
| 目标 | 目标 | 在退火周期中最小化的实值函数。 |

D-Wave Ocean 软件是一套开源 Python 工具，用于使用量子计算机解决困难问题，帮助重新表述应用程序的问题，以获得量子计算机或量子经典混合工作流的解决方案。它还处理应用代码和量子计算机之间的通信，如图 [7-14](#Fig14) 所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig14_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig14_HTML.jpg)

图 7-14

海洋软件栈的可编程性(改编自[142])

以下是关于一个问题如何在 D-Wave 量子计算机上运行的结构指南。

*   这些问题被公式化为伊辛模型或曲波模型。

*   当问题被编程到 D-Wave QPU(量子处理单元)上时，常数 a 和 b 被转换成电压、电流和磁场。

*   量子位自旋从它们的叠加态开始。

*   量子位自旋进化，探索问题空间。

*   在退火周期结束时，系统处于基态，或者是所提交问题的低激发态。

*   自旋的状态被读取，可选的后处理被应用，并被传送回用户。

*   这可以每秒进行数百或数千次

图 [7-15](#Fig15) 以 NP-hard 旅行推销员问题为例，描述了量子退火系统[38]中端到端编程的全栈工作流。TSP 将在本章后面的实践编码中描述。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig15_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig15_HTML.png)

图 7-15

全栈量子退火工作流程(改编自[38])

D-Wave 的系统利用了曲波。作为一个快速回顾，以下是 D-Wave 的编程过程所利用的曲波属性。

*   变量的最高幂是 2。

*   没有对变量应用任何约束。

*   变量值在{0，1}内。

*   最小化或最大化目标函数。

在这一章的前面，曲波背后的理论包括一个使用*对称形式*的例子。D-Wave 编程通常利用定义曲波的*上三角形式*。在图 [7-16](#Fig16) 中，图表 A 显示了曲波的矩阵表示。图 B 是同一表达式的图示:2*x*+3*y*-4*z*+*xy*-2.5*xz*+7*yz*。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig16_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig16_HTML.jpg)

图 7-16

曲波论 D-Wave(改编自[142])

以下是图 [7-16](#Fig16) 中图 A 的*矩阵*表示中的规则。

*   二次项出现在非对角线上。

*   对于 D-Wave 的海洋，上对角线就足够了。

*   在这种表示法中，常数项和变量名通常被省略。

*   线性项出现在对角线上。

当用图形表示曲波时，如图 [7-16](#Fig16) 中的图 B，我们遵守以下规则。

*   二次项出现在边缘。

*   在这种表示法中，常数项和变量名通常被省略。

*   线性项出现在节点上。

被描述为描述经典或量子系统的能量的对象的哈密顿量，也描述了由依赖于时间(即，状态演化依赖于时间)的薛定谔方程表达的随时间演化的系统:![$$ i\mathit{\hslash}\frac{d\mid \left.\psi (t)\right\rangle }{dt}=H\mid \left.\psi (t)\right\rangle $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq31.png)。

如果薛定谔方程解了一段时间 *t* ，其中*U*=*e*T6*iHt*/，那么我们就得到一个辅助状态演化的幺正算符。注意，这里的哈密顿量描述了系统的能量:*h*∣*ψ*(*t*)⟩=*e*∣*ψ*(*t*)⟩，其中 *E* 为能量。

#### 绝热量子计算

典型地，在绝热过程中，条件演化得足够慢，以使系统适应新的配置。例如，在一个量子力学系统中，我们可以从某个哈密顿量 *H* <sub>*i*</sub> 开始，慢慢地把它变成另一个哈密顿量 *H* <sub>*i* + 1</sub> 。最简单的演变可以用线性时间表来描述。

*h*(*t*=(1-*t*)*<sub>*【I】*</sub>+*

 **哈密顿量的时间依赖性使得薛定谔方程解的推导相当复杂。绝热定理指出，含时哈密顿量的缓慢演化(变化)应该有助于保持所得到的动力学简单。因此，如果我们开始接近一个本征态，系统保持接近一个本征态。这意味着，如果在某些*条件*下系统将在基态*E*T20 启动，那么系统将停留在*E*T8】0 或非常接近于*E*T12】0 的状态。

两个状态(例如基态和第一激发态)之间的能级差异被称为*能隙*或*能隙*。如果在过渡期间 *H* ( *t* )对于每个 *t* 具有非负间隙，并且变化适当缓慢地发生，则系统应该停留在基态。如果时间相关间隙由δ*t*给出，则速度限制的近似值按比例缩放为![$$ \raisebox{1ex}{$1$}\!\left/ \!\raisebox{-1ex}{$1\Delta {t}^2$}\right. $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq32.png)。

绝热定理允许一些相当不寻常的事情:可以获得一个容易求解的量子多体系统的基态，哈密顿量*变成了*我们感兴趣的系统。作为一个例子，可以从简单的哈密顿量![$$ {H}_0=-\sum \limits_i{\sigma}_i^x $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq33.png)开始，因为它的基态是相等的叠加态。作为一个利用 D-Wave 的`dimod` API、 <sup>[ 8 ](#Fn8)</sup> 的动手示例，我们在两个站点上进行了尝试，如 Jupyter 笔记本`Annealing_QC_DWave.ipynb`所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figs_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figs_HTML.jpg)

```
import numpy as np
np.set_printoptions(precision=3, suppress=True)

X = np.array([[0, 1], [1, 0]])
IX = np.kron(np.eye(2), X)
XI = np.kron(X, np.eye(2))
H_0 = - (IX + XI)
λ, v = np.linalg.eigh(H_0)
print("Eigenvalues:", λ)
print("Eigenstate for lowest eigenvalue", v[:, 0])

Listing 7-6aLibraries and Arrays Annealing_QC_DWave.ipynb

```

以下是 NumPy 文档[155]中代码块使用的一些函数的描述。

*   `numpy.kron()`或`np.kron():``NumPy`中两个数组的克罗内克乘积。计算 Kronecker 积，这是一个复合数组，由第二个数组的块按第一个数组的比例组成。

*   `numpy.linalg.eigh`()或`numpy.linalg.eigh`():返回复厄米(共轭对称)或实对称矩阵的特征值和特征向量。

清单 [7-6a](#PC38) 给出了以下作为特征值和本征态计算的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figt_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figt_HTML.jpg)

一旦知道了本征值和本征态，哈密顿量就可以慢慢地转化为经典的伊辛模型，从而得到整体解。绝热量子计算过程利用了这一现象，并可以在最终哈密顿量与方程 [7.4](#Eque) 中的*一般*形式相同的情况下进行计算。

![$$ H=-\sum \limits_i{h}_i{\sigma}_i-\sum \limits_{ij}J{\sigma}_i{\sigma}_j $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_Equax.png)

通过遵守速度限制和保证有限间隙来实现哈密顿量的量子计算系统可以被认为近似等同于门模型。

#### 量子退火

绝热量子计算的一个主要限制是速度极限的计算，这是很重要的。计算速度极限通常比解决寻找感兴趣的哈密顿量的基态的主要问题更难。此外，还有工程上的限制，例如量子位元的消相干和温度控制。*量子退火*通过绕过限速挑战解决了这些挑战。它反复重复*退火*(或跃迁)，直到收集到几个样本，能量最低的自旋组态被选为优先解。然而，通常不能保证这就是基态。

量子退火的软件栈与门模型量子计算机略有不同，如图 [7-15](#Fig15) 所示。代替量子电路，抽象层次是以经典伊辛模型的形式，并且*感兴趣的问题*以同样的形式被公式化。伊辛模型的经典解算器是*模拟退火炉*。

```
import dimod
J = {(0, 1): 1.0, (1, 2): -1.0}
h = {0:0, 1:0, 2:0}
model = dimod.BinaryQuadraticModel(h, J, 0.0, dimod.SPIN)
sampler = dimod.SimulatedAnnealingSampler()
response = sampler.sample(model, num_reads=10)
print("Energy of samples:")
print([solution.energy for solution in response.data()])

Listing 7-6bEnergy Annealing_QC_DWave.ipynb

```

这里，我们使用`dimod` API，它包含一个二进制二次模型(BQM)类，该类包含 D 波采样器使用的伊辛和二次无约束二进制优化(曲波)模型，以获得以下输出作为样本的能量。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figu_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figu_HTML.jpg)

为了在基于退火的量子系统中获得所需的解决方案，我们需要在编程期间将问题的连通性与硬件相匹配。要实现这一点，就需要找到一种将几个物理量子位组合成一个逻辑量子位的图形镜像嵌入。

次要嵌入问题的部分是 NP 难的(在下一节解释)。因此，概率方法找到了一个嵌入。例如，对于 D-Wave 生产的某些代量子退火机，量子位垂直或水平地“定向”在 QPU(量子处理单元)上，并具有包含一个 *K* <sub>4，4</sub> *二分全连通图*的单位单元，从每个量子位到相邻单位单元中的量子位有两个远程连接。图 [7-17](#Fig17) 显示了一个单元及其本地和远程连接。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig17_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig17_HTML.jpg)

图 7-17

嵌合图中的单位细胞(来源 D-Wave 文档[155])

图 [7-17](#Fig17) 称为嵌合图。在每一个渲染图[155]中，有两组四个量子位。每个量子位连接到另一组中的所有量子位，但不单独连接到任何一个，形成一个*K*T4】4，4 图；例如，标有 0 的绿色量子位连接到粗体的量子位 4 到 7。

Chimera 图在`dwave_networkx`包中以 NetworkX 图的形式提供。我们的示例绘制了图 [7-17](#Fig17) 的缩小版，利用了`chimera_graph()`函数，由 2 × 2 个单位单元组成。

```
import matplotlib.pyplot as plt
import dwave_networkx as dnx
%matplotlib inline
connectivity_structure = dnx.chimera_graph(2, 2)
dnx.draw_chimera(connectivity_structure)
plt.show()

Listing 7-6cCells in Chimera graph Annealing_QC_DWave.ipynb

```

该代码片段产生了图 [7-18](#Fig18) 中的以下输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig18_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig18_HTML.jpg)

图 7-18

嵌合图中的 2 × 2 单位细胞

我们可以生成不同的图形——例如，4 × 4 个单位单元，如图 [7-19](#Fig19) 和`connectivity_structure = dnx.chimera_graph(4, 4).`所示。然而，图 [7-18](#Fig18) 中的 2 × 2 个单位单元是为了视觉清晰。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig19_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig19_HTML.jpg)

图 7-19

嵌合图中的 4 × 4 单位细胞

接下来，我们尝试一个具有不同*连接结构*的图，例如，16 个节点的完整*K*<sub>T5】n</sub>图。

```
import networkx as nx
G = nx.complete_graph(16)
plt.axis('off')
nx.draw_networkx(G, with_labels=False)

Listing 7-6d16-node graph Annealing_QC_DWave.ipynb

```

这产生了图 [7-20](#Fig20) 中的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig20_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig20_HTML.jpg)

图 7-20

在 16 个节点上完成*K*<sub>T3】nT5</sub>

一个完整的 *K* <sub>*n*</sub> 图有九个节点，代码为`G = nx.complete_graph(9)`将给出图 [7-21](#Fig21) 中的图。为了视觉上的方便，我们继续这个九节点图。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig21_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig21_HTML.jpg)

图 7-21

在 9 个节点上完成*K*<sub>T3】nT5</sub>

在我们的下一步中，我们尝试嵌入图 [7-21](#Fig21) 的图形并绘制它。

```
import minorminer
embedded_graph = minorminer.find_embedding(G.edges(), connectivity_structure.edges())
dnx.draw_chimera_embedding(connectivity_structure, embedded_graph)
plt.show()

Listing 7-6eEmbed 9 Node Graph Annealing_QC_DWave.ipynb

```

清单 [7-6e](#PC42) 给出了以下输出，作为九个节点的*K*<sub>*n*</sub>=*K*<sub>9</sub>图嵌入。如果这个片段运行了不止一次，那么我们可能会看到结构的变化；也就是说，可以获得不同的嵌入。这些结果都没有错。它们都是可能的正确图形。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig22_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig22_HTML.jpg)

图 7-22

9 个节点的嵌入

在图 [7-22](#Fig22) 中，具有相同颜色的量子位对应于图 [7-21](#Fig21) 的 *K* <sub>9</sub> 图定义的原问题中的一个逻辑节点。量子位结合形成了一条链。虽然这个问题有 9 个变量(节点)，但玩具嵌合体图上几乎所有 32 个可用的变量都被用上了。清单 [7-6f](#PC43) 给出了最大链条长度。

```
max_chain_length = 0
for _, chain in embedded_graph.items():
    if len(chain) > max_chain_length:
        max_chain_length = len(chain)
print(max_chain_length)

Listing 7-6fMaximum Chain Length Annealing_QC_DWave.ipynb

```

输出是值 4。

硬件上的`chain`是通过元素间的强耦合实现的；这个链条的强度是用户所能设定的两倍。但是，长链仍然可能断裂，导致偶尔出现不一致的结果。一般来说，较短的链是优选的，以最小化量子位的浪费并获得更可靠的结果。

如果你对探索 D-Wave 的力量感兴趣，请前往 [`www.youtube.com/playlist?list=PLPvKnT7dgEsujrrP7i_mgbkivBN3J6A8u`](http://www.youtube.com/playlist%253Flist%253DPLPvKnT7dgEsujrrP7i_mgbkivBN3J6A8u) 参加乔尔·戈特利布博士(前 D-Wave)关于实用量子计算基础的三部分免费量子计算辅导课程。

## 解决 NP 难问题

对于一个在计算上可行的问题，它必须在所谓的 T2 多项式时间内是可计算的。多项式时间是指找到一个解所需的计算步数，对于一个大小为 *n* 和某个常数 *c* 的问题，必须是多项式函数 *n* <sup>*c*</sup> 。任何需要多项式以上的步骤来计算的问题；例如，指数级的 *c* <sup>*n*</sup> 步数被认为是不可行的，因为计算时间随着问题规模增长得太快，需要比宇宙年龄更多的时间来计算像 *n* ≃ 100 这样小规模的问题。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig23_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig23_HTML.png)

图 7-23

问题的复杂性

根据问题的可行性，将问题分成不同的复杂类别。最相关的复杂性类别及其关系如图 [7-23](#Fig23) 所示。

*   **BQP(有界误差量子多项式** **时间)**:使用量子计算机可以在多项式时间内高效解决问题。BQP 类包括 P 和至少一些 NP-中级的问题。然而，BQP 类*不包括* NP 难或 NP 完全问题。例子包括整数因式分解(NP-intermediate)和量子系统的模拟。

*   **P(多项式时间)**:P 中的问题定义为可以在多项式时间内*高效解决*的问题。这些问题被认为在经典计算机上是可行的。例如整数乘法、排序和列表搜索。

*   **NP(非确定性多项式时间****)**:NP 中的问题是可以被*高效验证的问题*；也就是说，可以在多项式时间内确认有效解。如果 P≠ NP，则*不*也在 P 中的 NP 问题不可能被有效解决(如 P 和整数因式分解中的所有问题)。

*   **NP-hard** 和 **NP-complete** : NP-hard 问题*至少*和 NP 中的每一个问题一样难；也就是说，相当于用一些额外的开销来解决一个 NP 问题。这样的问题如果也在 NP 中，就是 NP 完全的。

    NP-hard 问题不能有效地解决。然而，大多数有用的问题在现实世界中可能是 NP 难的，包括广泛适用于许多学科的基本问题，从密码学到调度到解决数独，等等[153]。幸运的是，存在可接受的近似解，使得足够小的 NP 困难问题可以用可接受的努力量来解决，但是总是有改进算法的空间。例如旅行推销员问题、停顿问题、地图着色和最大割问题。其中，我们在实践练习中尝试了最大割问题。在第 [8](8.html) 章中，我们还会看到用 D-Wave 编译器编码一个更复杂的旅行推销员问题。

## 无监督学习和优化

在本章的前面，我们看了监督学习和 qSVMs 的一些方面。*无监督学习*意味着缺乏标签(参见章节 [2](2.html) 和 [3](3.html) )，我们在数据中寻找结构，而没有对该结构特征的直觉。无监督学习的一个常见例子是聚类，其目标是识别在一些高维空间中聚集在一起的实例。一般来说，与有监督的学习相比，无监督的学习更难解决问题。深度学习为激励监督学习注入了巨大的推动力。它引发了无监督学习的重大进展。然而，仍有很大的改进余地。在下面的代码示例中，我们探索了将无监督学习问题映射到图优化的方法，这可以在量子计算机上解决。

我们考虑的第一个问题是聚类到优化的映射。假设有![$$ {\left\{{x}_i\right\}}_{i=1}^N $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq34.png)个点是高维空间![$$ {\mathcal{H}}^D $$](../images/502577_1_En_7_Chapter/502577_1_En_7_Chapter_TeX_IEq35.png)的成员。为了形成聚类，我们需要能够定义、区分和分组彼此靠近的点和彼此远离的点。为了更好地理解，让我们用公式表示一个包含两个类的数据集:前十个实例属于第一类，后十个实例属于第二类。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figv_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figv_HTML.jpg)

```
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
%matplotlib inline

n_instances = 20
class_1 = np.random.rand(n_instances//2, 3)/10
class_2 = (0.6, 0.1, 0.05) + np.random.rand(n_instances//2, 3)/10
data = np.concatenate((class_1, class_2))
colors = ["red"] * (n_instances//2) + ["green"] * (n_instances//2)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d', xticks=[], yticks=[], zticks=[])
ax.scatter(data[:, 0], data[:, 1], data[:, 2], c=colors);

Listing 7-7aData Points 3-D unsupervisedLearning.ipynb

```

这为我们提供了数据点的三维可视化。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figw_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figw_HTML.jpg)

作为一个额外的例子，如果我们希望我们的数据点在一个二维空间中，下面的代码片段将为每个类生成五个实例。

```
import matplotlib.pyplot as plt
import numpy as np
%matplotlib inline
np.set_printoptions(precision=3, suppress=True)
np.random.seed(0)

# Generating the data
c1 = np.random.rand(5, 2)/5
c2 = (-0.6, 0.5) + np.random.rand(5, 2)/5
data = np.concatenate((c1, c2))
plt.subplot(111, xticks=[], yticks=[])
plt.scatter(data[:, 0], data[:, 1], color='navy')

Listing 7-7b2-D Data Points

```

清单 [7-7b](#PC45) 给出了以下输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figx_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figx_HTML.jpg)

欧几里德距离测量是在高维空间中测量的最简单的情况。可以使用列表 [7-7c](#PC46) 计算数据点之间的成对距离。

```
import itertools
d = np.zeros((n_instances, n_instances))
for i, j in itertools.product(*[range(n_instances)]*2):
    d[i, j] = np.linalg.norm(data[i]-data[j])
print("The distances are ", d)

Listing 7-7cGram Matrix unsupervisedLearning.ipynb

```

这将打印点之间的距离，如以下截断的输出所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figy_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figy_HTML.jpg)

列表 [7-7c](#PC46) 生成的矩阵称为*克*矩阵或*核矩阵*。Gram 矩阵包含高维空间中点的拓扑信息。Gram 矩阵可以解释为图的加权邻接矩阵:两个节点代表两个数据实例。如 Gram 矩阵中所定义的，点之间的距离是连接它们的边上的权重。如果距离为零，则它们没有通过边连接。这是一个有很多边的密集图，通过施加一个指数级变小的距离函数，可以改善可视化。

我们可能想知道这些图表在我们寻找星团的任务中有多有效。这就是我们可以考虑最大割的地方，这是一个边的集合，如果删除，它会将图一分为二，同时最大化这些边的总权重，如 Otterbach 等人 2017 [159]所示。这是一个众所周知的自然映射到伊辛模型的 NP-hard 问题。

### 退火最大切割(D 波)

最大割是一个 NP 难的图论问题，正如理查德·卡普[156]在 1972 年发表的开创性论文以及其他 20 个 NP 难问题中所显示的。计算机科学家、数据科学家和数学家对 Max-Cut 进行了广泛的研究。问题的 NP 难性质无法在多项式时间内求解，但可以在多项式时间内验证。由于 NP-hard 问题没有多项式时间算法，所以对近似算法和启发式算法进行了大量的研究。最大割(Max-Cut)图问题简单地说就是将图的节点分成两个子集，使得子集之间的边数最大化。

最大割问题在现实世界中有广泛的应用，例如计算机网络。假设有各种服务器，每一个都有不同类型的接口(即，一些有 10 Gb 以太网端口，一些有 USB 端口，一些有蓝牙)。我们的目标是将这些计算机分为两组，用于两个不同的项目，以保证两组可以连接。然而，在现实生活中，连接经常由于物理和逻辑系统的不匹配而失败。这里的目标是计算保持联系的最佳方式。

最大割理论为我们提供了一种方法。为了创建我们的服务器网络的工作模型，我们可以将服务器形成的图可视化为节点(或顶点)，并且在服务器之间绘制边，以便它们可以连接，如图 [7-24](#Fig24) 所示。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Fig24_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Fig24_HTML.png)

图 7-24

最大割问题

图 [7-24](#Fig24) 的左侧是一个图表，右侧是同一图表的可能最大割解。两个分区分别是 *P* <sub>1</sub> = {1，4}和 *P* <sub>2</sub> = {2，3，5}。最大切削尺寸为 *f* ( *x* ) = 5，其中 *x* = (1，1，1，1)。值得注意的是，这个例子有多个解决方案(具有相同大小切割的分区)，这是其中一个例子。

如果我们在图中寻找一个最大割，我们希望把节点分成两组，这样在两组之间就有尽可能多的边。然后，在我们的服务器网络中，我们有两个组，这两个组之间有尽可能多的连接。现在，如果一个连接断开，我们可以使用多个连接作为冗余路径。该解决方案通过在一个连接出现故障时在组之间提供冗余连接，帮助创建更具弹性的网络。

量子退火是可视化 NP 难最大割问题的一种强有力的方法。为了了解这是如何做到的，我们使用 D-Wave 的`dimod`和 NetworkX ( [`https://docs.ocean.dwavesys.com/projects/dwave-networkx/en/latest/`](https://docs.ocean.dwavesys.com/projects/dwave-networkx/en/latest/) )等等来看一个 12 节点最大割问题。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figz_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figz_HTML.jpg)

```
import numpy as np
import matplotlib.pyplot as plt
import dwave_networkx as dnx
import networkx as nx
from dimod import ExactSolver, SimulatedAnnealingSampler

Listing 7-8aMax-Cut Libraries and Preliminaries maxcut_DWave.ipynb

```

`SimulatedAnnealingSampler()`是一个使用模拟退火算法的`dimod`采样器。清单 [7-8b](#PC48) 定义了 12 个节点及其连接，并调用`dwave_networkx()`【154`]`函数来创建图形。

```
sampler = SimulatedAnnealingSampler()
G = nx.Graph()
G.add_edges_from([(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),
(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),
(2,6),(2,7),(2,8),(2,9),(2,10),(2,11),
(3,6),(3,7),(3,8),(3,9),(3,10),(3,11),
(4,6),(4,7),(4,8),(4,9),(4,10),(4,11),
(5,6),(5,7),(5,8),(5,9),(5,10),(5,11)])
pos = nx.spring_layout(G)
nx.draw(G,pos,with_labels=True)
nx.draw_networkx_nodes(G,pos)
plt.show()
candidate = dnx.maximum_cut(G, sampler)
print (candidate, " is the maxcut")
S = dnx.maximum_cut(G, ExactSolver())
print (S, " is the maxcut")

Listing 7-8bGraph Generation maxcut_DWave.ipynb

```

代码片段给出了以下输出，作为我们的 Max-Cut 解决方案。由于计算的概率性质，每次运行的解可能不同。这并不意味着任何解决方案都是错误的。都是正确的！

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figaa_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figaa_HTML.jpg)

我们生成了具有明确定义的边和节点的图。作为练习，我们可以随机选择节点并观察解决方案的质量。

```
seed = random.randrange(1, 1000)
G1 = nx.erdos_renyi_graph(n=12, p=0.3, seed=seed)
pos = nx.spring_layout(G1)
nx.draw(G1,pos,with_labels=True)
plt.show()
sampler = SimulatedAnnealingSampler()
candidate = dnx.maximum_cut(G1, sampler)
print (candidate, " is the maxcut")
S = dnx.maximum_cut(G1, ExactSolver())
print (S, " is the maxcut")

Listing 7-8cGraph Generation maxcut_DWave.ipynb

```

在清单 [7-8c](#PC49) ，`erdos_renyi_graph` <sup>[9](#Fn9)</sup> 是 Python NetworkX 的一部分。它返回一个 *G* <sub>*n* ， *p*</sub> 随机图，也称为 Erdős-Rényi 图或*二项式*图。 *G* <sub>*n* ， *p*</sub> 模型以概率`p`(此处概率赋值为 30%)选择每个可能的边。该算法在*O*(*n*<sup>2</sup>)时间内运行。`random()`功能产生给定范围内的伪随机数(见 [`https://docs.python.org/3/library/random.html`](https://docs.python.org/3/library/random.html) )。下面是代码块的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figab_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Figab_HTML.png)

由于节点选择的随机性，这个解看起来比前一个更随意。由于计算的概率性质，每次运行的解可能不同。

### 用 QAOA (pyQuil)进行最大切割

既然你已经对 Max-Cut 有了深入的了解，并且已经看到了它在 D-Wave 量子退火上的工作，同样的 Max-Cut 问题也可以在 Rigetti Forest 或其他门模型量子计算机上解决。为了实现这一点，翻译耦合和现场字段以匹配编程接口，如清单 7-9 所示(和以前一样，打开三个单独的终端来启动 QVM 服务器(`qvm -S`)、Quilc 服务器(`quilc -S`)和 Jupyter 笔记本(`jupyter notebook`)。导入必要的库并定义网络边。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figac_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figac_HTML.jpg)

```
# Import Libraries and define QVM  Connection
import numpy as np
from grove.pyqaoa.maxcut_qaoa import maxcut_qaoa
import pyquil.api as api
import matplotlib.pyplot as plt
import networkx as nx
qvm_connection = api.QVMConnection()

# assign network edges
nw_edges=[(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(7,0),(7,8),(8,9),(9,2),(9,10),(10,11),(11,4),(11,12),(12,6),(0,10),(3,12)]

Listing 7-9aAssign the Edges maxcut_QAOA_pyquil.ipynb

```

然后我们在 QVM 上运行优化。

```
steps = 2
inst = maxcut_qaoa(graph=nw_edges, steps=steps)
betas, gammas = inst.get_angles()
steps = 2
inst = maxcut_qaoa(graph=nw_edges, steps=steps)
betas, gammas = inst.get_angles()
t = np.hstack((betas, gammas))
param_prog = inst.get_parameterized_program()
prog = param_prog(t)
wf = qvm_connection.wavefunction(prog)
wf = wf.amplitudes
wlist = []
for state_index in range(2**len(inst.qubits)):
    ww = np.conj(wf[state_index])*wf[state_index]
    wlist.append([inst.states[state_index], ww.real])
wlist.sort(key=lambda x: float(x[1]),reverse=True)

Listing 7-9bRun Optimization on QVM maxcut_QAOA_pyquil.ipynb

```

以下是截断的输出。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figad_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figad_HTML.jpg)

我们可以通过`wlist`命令获得一个带有权重的分区解决方案列表(为了简洁起见，没有显示输出，但是包含在笔记本中)。

接下来，寻找最大分割分区。

```
mxcutlist0 = []
mxcutlist1 = []
for i in range(len(wlist[0][0])):
    if wlist[0][0][i] == '0':
        mxcutlist0.append(i)
    else:
        mxcutlist1.append(i)
print("maxcut0 is ",mxcutlist0)
print("maxcut1 is ",mxcutlist1)

Listing 7-9cMax-Cut Partitions maxcut_QAOA_pyquil.ipynb

```

分区的输出如下。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figae_HTML.jpg](../images/502577_1_En_7_Chapter/502577_1_En_7_Figae_HTML.jpg)

我们可以从下面的代码片段中生成最大割图和分区。

```
G1 = nx.Graph()
G1.add_edges_from(nw_edges)
pos = nx.spring_layout(G1)
#gd.draw_custom(G2,pos)
nx.draw(G1,pos,with_labels=True)
plt.show()
print("The first set from maxcut partioning is ",mxcutlist0)
print("The second set from maxcut partioning is ",mxcutlist1)

Listing 7-9dMax-Cut Graph maxcut_QAOA_pyquil.ipynb

```

下面的输出显示了我们在 pyQuil 中的 Max-Cut 解决方案和分区的图表。

![../images/502577_1_En_7_Chapter/502577_1_En_7_Figaf_HTML.png](../images/502577_1_En_7_Chapter/502577_1_En_7_Figaf_HTML.png)

由于计算的概率性质，输出图可能因运行而异。

最大割问题的一个常见实际例子是超大规模集成(VLSI)电路设计在引脚预分配和层偏好中的应用。另一个常见的例子是应用外磁场寻找自旋玻璃的基态。巴拉霍纳等人(2016 年)[157]对这两种情况都进行了研究。

解决 Max-Cut 等问题是基于退火的量子计算机(如 D-Wave)的强大功能的一个例子。据推测，基于 QAOA 的 Max-Cut 解决方案需要基于门的量子计算机上的数百个量子位才能实现任何潜在的量子加速优势(Guerreschi 等人，2019 年)[158]。

### 摘要

本章着眼于量子计算和机器学习中一些非常重要和常用的算法和技术，如 VQE、曲波、QAOA 和 HHL。它推出了 D-Wave 的退火系统，这是世界上第一台商业化生产的量子计算机。使用各种平台和优化技术解决类似问题的方法在下一章很有帮助，我们将探索更复杂的优化问题的实践示例，如 TSP、量子深度学习、量子神经网络和利用 Xanadu 的 PennyLane 的量子机器学习。

<aside aria-label="Footnotes" class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

未计算: [`https://en.wikipedia.org/wiki/Uncomputation`](https://en.wikipedia.org/wiki/Uncomputation)

  [2](#Fn2_source)

矩阵的条件数被定义为最大奇异值与最小奇异值之比，并且当最小奇异值为 0 时是未定义的。一般来说，当矩阵的奇异值介于其条件数的倒数和 1 之间时，该矩阵被称为“条件良好的”。

  [3](#Fn3_source)

Z.赵，A. Pozas-Kerstjens，P. Rebentrost，p .，《量子计算机上的贝叶斯深度学习》，(2018)，arXiv:1806.11463 [quant-ph]， [`https://arxiv.org/abs/1806.11463`](https://arxiv.org/abs/1806.11463) ，本书参考文献[113]。

  [4](#Fn4_source)

例如，参见 [`https://en.wikipedia.org/wiki/Ising_model`](https://en.wikipedia.org/wiki/Ising_model)

  [5](#Fn5_source)

哈伯德模型: [`https://en.wikipedia.org/wiki/Hubbard_model`](https://en.wikipedia.org/wiki/Hubbard_model)

  [6](#Fn6_source)

neld-mead:[`https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method`](https://en.wikipedia.org/wiki/Nelder%25E2%2580%2593Mead_method)

  [7](#Fn7_source)

参考: [`https://en.wikipedia.org/wiki/Lie_product_formula`](https://en.wikipedia.org/wiki/Lie_product_formula)

  [8](#Fn8_source)

dimod 是采样器的共享 API(参见 [`https://github.com/dwavesystems/dimod`](https://github.com/dwavesystems/dimod) )。它提供了一个二元二次模型(BQM)类，包含 D-Wave 系统等采样器使用的伊辛和二次无约束二元优化(曲波)模型；离散二次模型(DQM)类和高阶(非二次)模型；以及采样器和合成采样器的参考示例。

  [9](#Fn9_source)

参考: [`https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.generators.random_graphs.erdos_renyi_graph.html`](https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.generators.random_graphs.erdos_renyi_graph.html)

 </aside>***