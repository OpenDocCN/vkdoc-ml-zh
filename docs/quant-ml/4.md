# 四、量子信息科学

云彩飘进了我的生活，不再带来雨水或风暴，而是给我落日的天空增添色彩。

—罗宾德拉纳特·泰戈尔

量子信息涉及利用量子力学的特性来处理和传输信息。量子信息是指可以物理存储在量子系统中的数据。量子信息理论是研究这种信息如何被编码、测量和操纵的。*量子计算*是量子信息的一个子领域。它经常被用作量子信息理论的同义词，量子信息理论研究使用量子系统执行计算的协议和算法。

引用加州理工学院量子计算大师约翰·普雷斯基尔教授的话，“信息是以物理系统的状态编码的东西。”传统上，计算是在物理上可实现的设备上进行的。因此，一个不可回避的事实是，对计算信息过程的研究应该与对潜在的物理过程的研究内在地联系起来。

Note

本章重点介绍量子信息科学的基础知识，如量子并行性、Deutsch 算法、Qiskit 和 Google 的 Cirq 实践练习以及相关理论。本章以介绍量子计算系统作为我们处理的各种平台的先驱而结束。这应该为你在本书的未来章节中更深入地钻研量子算法和机器学习的应用做好准备。

物理学的发展与信息的使用和操作有显著的关系。1961 年提出的兰道尔原理指出，信息的擦除本质上是一个耗散过程。例如，我们可以考虑一个假设的“盒子里的原子”的情况，其中一个原子被放置在一个中间有水平隔板的充满气体的盒子里。如果原子被移动到分区的下半部分，它将被擦除，不管它是从顶部还是底部开始。分开上下两半的隔板突然移开，活塞压缩单原子气体，直到原子被限制在下半部分。压缩气体的行为导致气体熵的减少。单原子理想气体的熵 *S* 的*变化*给出如下【28】。

![$$ \varDelta S= Nk\left( lnln\ \frac{V_f}{V_i}\ \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equa.png)

其中 *N* 为原子数， *k* 为玻尔兹曼常数， *V* <sub>*f*</sub> 为压缩后的最终体积， *V* <sub>*i*</sub> 为初始体积。随着熵的变化，从“盒子”到环境的热量也随之变化。如果我们认为系统是等温的(即温度保持恒定在 *T* 的系统)，则在盒子上做功![$$ W= kTlnln\ \left(\frac{V_f}{V_i}\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq1.png)。如果用来擦除信息，就必须付出代价，也许是电费或煤气费。

根据朗道原理，如果电池供应有限，那么计算时间就应该有一个理论极限。然而，随着我们对信息物理学的理解不断发展，查尔斯·贝内特提出了这个理论。他在 1973 年指出，计算可以只用可逆的步骤来完成。原则上不需要耗散，不需要电力支出；于是，*可逆计算*。

根据理论，不需要付费来执行计算。然而，在实践中，今天使用的“不可逆”计算机消耗了大量的能量，数量级高于估计值![$$ kTlnln\ \left(\frac{V_f}{V_i}\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq2.png)。随着计算组件不断变得越来越小，*击败*兰道尔原理变得越来越重要，这样组件就不会在产生的热量中腐蚀或熔化；因此，可逆计算可能是留给工程的唯一选择。因此，*量子信息*演变为今天物理学和计算机科学的接口。

## 量子信息

经典信息论源于“信息是物理的”这一基本原则，本能地，它对我们思考信息的物理解释具有指导意义。在很大程度上征服了经典信息的大部分细节之后，我们必须考虑量子力学的法则从根本上支配着宇宙。

量子物理学是真正的随机性所在，与其经典对应物相反，经典对应物很大程度上是确定性的。在量子理论中，不可交换的可观察量不能同时具有由海森堡测不准原理描述的精确定义的值(第 [1](1.html) 章)。此外，如果对变量 *x* 进行测量，那么如果 *x* 和 *y* 不互换，则该测量行为会影响可观察变量 *y* 的后续测量结果。这意味着获取关于物理系统的信息的行为扰乱了物理系统；这不是经典物理学所受的限制。

信息由物质和能量的配置来表示；因此，信息存储、传输和处理的方式是由物理系统的法则决定的。在人类可以理解的尺度上，相关的物理定律是量子力学的定律。因此，量子信息是研究量子理论如何影响我们概念化和处理信息的能力。图 [4-1](#Fig1) 是量子信息处理的图示。

这导致了对如何理解和管理复杂的量子系统的信息携带特性的研究。对量子领域信息科学的日益了解为传统“经典”信息理论不可能实现的新应用打开了大门，例如*完美*安全通信、量子系统的高效模拟和超快量子计算机。近年来，在将量子信息带入现实世界方面，人们的兴趣和进展出现了爆炸式增长。它还提供了对物理、计算和信息的基本性质的见解。在实验室之外，第一批商用量子设备已经出现在市场上。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig1_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig1_HTML.jpg)

图 4-1

量子信息处理的概念

在物理系统中制造扰动以获取信息之间的权衡是由于量子系统的随机性。从一个量子系统中获取信息也会引起一个与*不可克隆定理* *，*相关的扰动，该定理指出量子信息不能被完美保真地复制。如果有可能完美地复制量子信息，这将使我们能够在不干扰原件的情况下测量副本的可观测属性，从而使我们能够绕过“测量时被干扰”的属性。但是，不可克隆定理禁止这种行为。正如我们所知，没有什么能完美地阻止经典信息的复制。几十年来，当任何人试图备份数据库或硬盘，甚至试图复制粘贴简单的文本时，这一特性都帮助了计算用户及其更大的生态系统。

### 量子电路和布洛赫球

量子计算电路是量子逻辑门的网络，其中每个门对一个或多个量子位执行某种特定的酉变换。与经典计算类似，量子电路是使用不同种类的运算选项构建的。这一部分详细阐述了第一章中提到的量子门的基础知识。它使用量子电路进行了一些实验，作为使用 Python 中的量子计算库进行编码的热身。这种电路是用量子门构建的，量子门一次对一个或两个量子位起酉算子的作用。这些电路可以使用本章中称为`qCircuitCirq.ipynb`的 Python 笔记本来运行。这段代码运行在谷歌 Cirq 量子模拟器上，包括一个量子隐形传态实验。

量子态空间由称为*希尔伯特空间*的复向量空间构成(在第 [1](1.html) 章中讨论)。在量子信息科学中，总是假设希尔伯特空间![$$ \mathbf{\mathcal{H}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq3.png)是有限维的。由于![$$ \mathbf{\mathcal{H}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq4.png)是有限维的，可以选择一个基将这个基中的向量表示为有限列向量，用有限矩阵表示算子。量子计算感兴趣的希尔伯特空间通常具有维度 *d* = 2 <sup>* n *</sup> ，对于某些正整数 *n* 。一个量子位状态可以被表示为 u，而没有任何一般性损失，如下所示。

![$$ \mid \psi \left\rangle = coscos\ \frac{\theta }{2}\mid 0\right\rangle + sinsin\ \frac{\theta }{2}\ {e}^{i\phi}\mid 1\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equb.png)

(4.1)

其中，通常，kets ∣0⟩和∣1⟩是正交基，0 ≤ *θ* ≤ *π* 和 0 ≤ *ϕ* ≤ 2 *π* 和 *i* 表示状态向量的虚部。这通常被称为*计算基础*，而不具体说明该基础的物理实现。在量子信息科学中，计算可视化有助于将这种状态映射到布洛赫球，如图 [4-2](#Fig2) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig2_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig2_HTML.jpg)

图 4-2

布洛赫球

布洛赫球是一个抽象的三维表示，用球上的一个点来表示量子位的状态。就布洛赫球而言，基态∣0⟩和∣1⟩分别是北极和南极。X 轴与球面相交的对跖点对应于以下标准正交态

![$$ \mid +\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equc.png)

(4.2)

![$$ \mid -\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle -|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equd.png)

(4.3)

方程式 [4.2](#Equc) 和 [4.3](#Equd) 类似于方程式 [1。19](1.html#Equv) 和 [1。20](1.html#Equw) 。换句话说，参照第 [1](1.html) 章， *H* ∣0⟩ = ∣ + ⟩，*h*∣1⟩=∣⟩.这些状态被称为*哈达玛基*，因为它们可以通过应用称为*哈达玛变换*、 *H* 的 2 × 2 酉矩阵从计算基中获得。

![$$ \left(\frac{\mid +\Big\rangle }{\mid -\Big\rangle}\right)=H\left(\frac{\mid 0\Big\rangle }{\mid 1\Big\rangle}\right)=\frac{1}{\sqrt{2}}\left(1\ 1\ 1-1\ \right)\left(\frac{\mid 0\Big\rangle }{\mid 1\Big\rangle}\right)=\frac{1}{\sqrt{2}}\left[\left(\frac{1}{0}\right)\pm \left(\frac{0}{1}\right)\right]=\frac{1}{\sqrt{2}}\left(|0\Big\rangle \pm |1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Eque.png)

(4.4)

哈达玛变换与泡利矩阵有关。参考等式 [1。13](1.html#IEq22) ，其给出了泡利矩阵的数学表示，我们看到 Y 轴与球体表面相交的对跖点对应于以下正交正态。

![$$ \mid i\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +i|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equf.png)

(4.5)

![$$ \mid -i\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle -i|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equg.png)

(4.6)

图 [4-3](#Fig3) 显示了布洛赫球上的一些量子位状态。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig3_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig3_HTML.jpg)

图 4-3

具有单量子位状态的布洛赫球(来源[31])

#### 布洛赫球面上的叠加

叠加在第 [1 章](1.html)中定义。由量子位构建的状态空间比由经典的二进制位*表示的对应状态空间携带更多的信息，因为量子位状态是根据两个连续的实参数 *θ* 和 *ϕ* 来指定的。换句话说，经典描述只告诉我们是在北半球还是南半球，而量子位状态向量区分的是布洛赫球表面的每一点。*

量子位状态通常被表示为∣0⟩和∣1⟩.基态的叠加如果对大量 N 个相同的单量子位状态进行测量，那么大约![$$ N\frac{\theta }{2} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq5.png)次输出为 0，大约![$$ N\frac{\theta }{2} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq6.png)次输出为 1。概率对量子世界的影响与经典世界有着显著的不同。

有可能在量子计算机上开始一个物理过程——无论是门还是退火过程——以∣0⟩为初始状态，然后让状态*演化*。这种状态的演变也可以通过使用哈达玛算符 *H* 来完成，类似于我们之前实验的 GHZ 电路。如果这是在一个*经典*系统上尝试，第一步，*经典推理，*说我们有 50%的机会在∣0⟩，50%的机会转到∣1⟩.现在假设该过程的第二步通过 Hadamard 算子再次进行进化。在这里，经典推理说，如果我们在第一步后仍在∣0⟩，有 50%的机会，我们会在第二步后留在∣0⟩；此外，如果我们碰巧在第一步后翻转到∣1⟩州，有 50%的可能性在第二步该州再次翻转，最终回到∣0⟩.因此，经典推理说，在应用*h*T10】2 之后，处于状态∣0⟩的总概率由下式给出，即 50%。

![$$ (0.5)(0.5)+(0.5)(0.5)=0.5 $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equh.png)

然而，如果我们现在考虑这样一个事实，即*h*T2】2 是一个*恒等运算符*(即等于 1)，那么我们认识到这个物理过程在 100%的时间里都将∣0⟩作为输出。这里的区别在于，量子测量产生的概率计算可以考虑干涉效应。用经典的波动行为来经典地模拟干涉是可能的，但这是量子物理已经内置于其中的固有属性。

在这个例子中暴露出的经典推理的局限性表明，我们在思考量子叠加态时应该小心。这是因为量子位状态![$$ \mid -\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle -|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq7.png)在∣0⟩和∣1⟩同时是*而不是*。它不在任何一个州。取而代之的是一种不同的物理状态，叫做∣− ⟩状态。在量子位元的某些物理实现中，阿达玛基底和计算基底一样是测量状态的好基底。如果用来测量的基被交换，那么|−⟩态就不是叠加态。对于希尔伯特空间中的任何状态，总是有测量基的选择，其中该状态是基状态之一，因此不是叠加态。因此，叠加是没有意义的，除非量子系统指出某些测量基础优于其他测量基础。

#### 具有 Qiskit 的量子电路

2017 年 3 月，IBM 宣布发布 IBM Quantum Experience，这是一个连接到用超导材料获得的真实量子处理器的平台。有可能通过云接入使用这个量子计算平台，在量子硬件系统上执行程序。Qiskit 允许管理真实和模拟的量子电路。编程可以通过图形界面或 CLI(命令行界面)来完成。量子计算环境还通过 API(应用编程接口)提供可编程性:一组用于与设备和模拟器接口以及运行实验的类、函数和数据结构。根据他们的 API 文档[275]，Qiskit 的框架有以下主要方面。

*   奇斯基特

*   Qiskit 模拟器(Aer)

*   齐斯基特实验(伊格尼丝)

*   Qiskit 应用模块(Aqua)

*   Qiskit IBM Quantum(提供商)

用 Qiskit 编写的程序遵循基于三个高级步骤的固定工作流。

1.  建立一个电路。

2.  执行程序。

3.  分析结果。

Qiskit 管理三个主要对象[275]来执行工作流:`provider`、`backend,`和`job`。`provider`提供了一组不同的`backend`来选择适合我们特定算法的。AER `provider`允许访问不同的模拟器，而 IBM `provider`允许通过 IBMQ 模块访问真实的量子位环境。

`backend`负责运行量子电路并返回结果。它们将一个`qobj`作为输入，并返回一个`BaseJob`对象。每个执行都由一个惟一的地址标识，可由`Job`对象访问，该对象找出给定时间点的执行状态(例如，如果作业正在排队、正在运行或已经失败)。Qiskit 工作流程如图 [4-4](#Fig4) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig4_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig4_HTML.jpg)

图 4-4

Qiskit 工作流

Qiskit 提供了用 Bloch 球模拟量子态空间的选项。要实现正确的可视化并在 Jupyter notebook 上正确操作，需要 Qiskit Terra 0.16 . x 版以及 Python 3.6 或更高版本。这可以在 Linux 环境中通过以下命令进行安装。

```py
$ pip install qiskit[visualization]

```

如果您已经安装了 Qiskit，并在没有 Qiskit Terra 0.16.x 提供的可视化更新的情况下尝试该代码，您可能会遇到以下错误。

```py
VisualizationError – input is not a valid N-qubit state.

```

如果您已经安装了 Qiskit 和较旧版本的 Terra，并且遇到了这个错误，请使用`-U`选项更新`qiskit[visualization]`。

如果您在 Windows 上有一个 Anaconda 环境，请在命令行窗口(`cmd.exe`)中打开一个 Anaconda 提示符，并键入以下内容。

```py
conda install qiskit[visualization] -U

```

这将启动图 [4-5](#Fig5) 所示的所有相关文件的更新、下载和安装。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig5_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig5_HTML.jpg)

图 4-5

Qiskit Terra 更新并安装在 Windows 上的 Anaconda 中

一旦 Qiskit 包成功安装，我们就可以使用 Bloch 球体尝试一些量子态的可视化练习。这解释了三维布洛赫表面上的矢量的解释。我们从导入`Qiskit`库开始，并使用清单 [4-1a](#PC4) 中所示的`plot_bloch_vector()`函数为 Jupyter 笔记本`qiskitBloch.ipynb`文件可视化一个样本 Bloch 球体。`qiskit.__qiskit_version__`显示所有 Qiskit 组件和 API 的工作版本。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figa_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figa_HTML.jpg)

```py
## import the libraries
import numpy as np
from qiskit import *
qiskit.__qiskit_version__

from qiskit.visualization import plot_bloch_vector
%matplotlib inline
plot_bloch_vector([0,1,0], title="Bloch Sphere")

Listing 4-1aBloch Sphere Simulation in qiskitBloch.ipynb

```

这段代码生成版本号和我们的示例 Bloch sphere 作为输出，如图 [4-6](#Fig6) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig6_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig6_HTML.jpg)

图 4-6

样本 Bloch 球体和版本号

Note

不要混淆量子位的状态向量和它的布洛赫向量。状态向量是保存量子位可能处于的两种状态的振幅的向量。Bloch vector 是一个可视化工具，它将二维的复杂状态向量映射到真实的三维空间。布洛赫球是纯态的几何表示。提供绘制斑点球的 Qiskit 函数是 plot_bloch_vector()。值得注意的是，每个布洛赫球代表一个量子位取向(即，两个量子位由两个布洛赫球代表；三个量子位需要三个布洛赫球，依此类推)。

了解 Qiskit 如何处理门定义是很有帮助的。我们在本章前面的 Qiskit 中遇到了 GHZ 态。为此，我们首先导入所有必要的库，如清单 [4-1b](#PC5) 所示，并尝试一个 X gate。当我们看泡利门(方程式 [1 时，x 门的定义在第](1.html#IEq22) [1 章](1.html)中有所涉及。13 。在这个例子中，使用了`plot_bloch_multivector()`函数，它接受一个量子位的状态向量，而不是 Bloch 向量。

```py
from math import pi
from qiskit.visualization import plot_bloch_multivector
#X-gate on a |0> qubit
qc = QuantumCircuit(1)
qc.x(0)
qc.draw()

Listing 4-1bGate Programming in qiskitBloch.ipynb

```

清单 [4-1b](#PC5) 给出以下电路作为输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figb_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figb_HTML.jpg)

这里，我们在状态![$$ \mid 0\Big\rangle =\left(\frac{1}{0}\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq8.png)对一个量子位执行了 x 或非门操作，并将其翻转到∣1⟩.状态让我们在一个布洛赫球表示上验证 X-gate 操作的结果，如清单 [4-1c](#PC6) 所示。

```py
# Verify The result
backend = Aer.get_backend('statevector_simulator') # Simulate
out = execute(qc,backend).result().get_statevector() # Do the simulation, returning the statevector
plot_bloch_multivector(out) # Display the output state vector

Listing 4-1cBloch Representation of the X-operation qiskitBloch.ipynb

```

清单 [4-1c](#PC6) 给出了下面的 Bloch 球表示作为输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figc_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figc_HTML.jpg)

输出证实了量子位的状态是预期的∣1⟩。这是绕布洛赫球的 X 轴旋转了 *π* 弧度。

Qiskit 库允许在电路中添加门。例如，如果我们要将 Pauli Y 和 Z gate 添加到我们之前创建的 X gate 中，我们需要清单 [4-1d](#PC7) 中的代码片段。

```py
qc.y(0) # Do Y-gate on qubit 0
qc.z(0) # Do Z-gate on qubit 0
qc.draw()

Listing 4-1dY and Z gate Addition to X Gate qiskitBloch.ipynb

```

这个代码片段给出了下面的电路作为输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figd_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figd_HTML.jpg)

Qiskit 仅允许测量 Z 基准。当进行测量时，并不总是要求以任何固定的计算基础(即 Z 基础)进行测量。量子位的测量可以在我们选择的任何基础上进行。例如，我们可以计算在 x 轴上测量∣+ ⟩或∣− ⟩的概率。

*p*(|+⟩)= |⟨+|*q*⟩|<sup>2</sup>，*p*(|−⟩)= |⟨−|*q*⟩|<sup>2</sup>

一旦测量完成，量子位就保证处于这两种状态之一。由于 Qiskit 只允许在 Z 基础上进行测量，因此需要我们使用 Hadamard 门创建自己的测量(参见清单 [4-1e](#PC8) )。

```py
# Create Hadamard gate for the X-measurement function:
def x_measurement(qc,qubit,cbit):
    """Measure 'qubit' in the X-basis, and store the result in 'cbit'"""
    qc.h(qubit)
    qc.measure(qubit, cbit)
    qc.h(qubit)
    return qc

initial_state = [0,1]
# Initialise our qubit and measure it
qc = QuantumCircuit(1,1)
qc.initialize(initial_state, 0)
x_measurement(qc, 0, 0)  # measure qubit 0 to classical bit 0
qc.draw()

Listing 4-1eHadamard qiskitBloch.ipynb

```

该代码片段给出了以下电路，其中 H 门和 M 门用于测量作为输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fige_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fige_HTML.jpg)

这些练习演示了通过将 Z 门夹在两个 H 门之间来创建 X 门是可能的。

![$$ X= HZH $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equi.png)T2】

计算从 Z 开始。然后 H 门将量子位切换到 X 基，之后 Z 门在 X 基中执行 NOT，最后另一个 H 门将量子位返回到 Z 基。接下来，我们使用与清单 [4-1c](#PC6) 相同的语法在 Bloch 球体上执行验证，并获得图 [4-7](#Fig7) 中的以下输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig7_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig7_HTML.jpg)

图 4-7

X gate 基础转移的验证

如果 Jupyter 笔记本单元格再次运行，您可能会看到不同的结果；然而，量子位的最终状态总是∣+ ⟩或∣− ⟩.量子位在|1⟩.状态下被初始化测量的结果是，∣+ ⟩和∣− ⟩.崩溃了

Qiskit 允许在真实设备或`qasm_simulator`上运行的量子电路的数据可视化。为了方便起见，有一个`plot_histogram(data)`函数。作为一个例子，看看如何用 Qiskit 创建钟形状态。两个量子位系统的计算基可以转换成由四个贝尔态定义的标准正交基。

##### 带 Qiskit 的贝尔州

当一个系统纠缠在一起时，各个独立的系统组成一个整体。任何测量系统的一部分——在我们的例子中是第一个粒子——的测量都是对整个系统的测量。然后系统的波函数坍缩，两个粒子都呈现确定的状态。两党制基础的一个流行例子是*贝尔基础*或*贝尔态*。两个量子位的贝尔态通常由下式给出。

![$$ \mid {\beta}_{00}\Big\rangle =\frac{1}{\sqrt{2}}\left(|00\Big\rangle +|11\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equj.png)

(4.7)

![$$ \mid {\beta}_{01}\Big\rangle =\frac{1}{\sqrt{2}}\left(|01\Big\rangle +|10\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equk.png)

(4.8)

![$$ \mid {\beta}_{10}\Big\rangle =\frac{1}{\sqrt{2}}\left(|00\Big\rangle -|11\Big\rangle \right)$$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equl.png)

(4.9)

![$$ \mid {\beta}_{11}\Big\rangle =\frac{1}{\sqrt{2}}\left(|01\Big\rangle -|10\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equm.png)

(4.10)

∣*β*T2⟩态被称为*三重态*。有三种三重态。另外两个是∣00⟩和|11⟩.∣*β*t8】11⟩被称为*单态*。清单 [4-1f](#PC9) 显示了一个构建铃态的量子电路，它打印铃测量计数，然后生成一个直方图。

```py
# quantum circuit to create a Bell state
bell = QuantumCircuit(2, 2)
bell.h(0)
bell.cx(0, 1)

meas = QuantumCircuit(2, 2)
meas.measure([0,1], [0,1])

# execute the quantum circuit
backend = BasicAer.get_backend('qasm_simulator') # the device to run on
circ = bell + meas
result = execute(circ, backend, shots=1000).result()
counts  = result.get_counts(circ)
print(counts)

from qiskit.visualization import plot_histogram
plot_histogram(counts)

Listing 4-1fBell State qiskitBloch.ipynb

```

这将产生以下输出，作为对响铃状态的测量计数。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figf_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figf_HTML.jpg)

图 [4-8](#Fig8) 中的直方图是从`qiskit.visualization.`调用的`plot_histogram()`函数的输出

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig8_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig8_HTML.jpg)

图 4-8

贝尔状态概率直方图

本节是一个热身练习，让我们深入了解 Qiskit 在接下来的章节中的操作，在接下来的章节中，我们将专注于定义更复杂的算法。

#### 具有 Cirq 的量子电路

量子计算机在基于门的量子计算机中，基于对量子位的酉门操作，作为量子电路执行程序。量子计算电路是量子逻辑门的网络，其中每个门对一个或多个量子位执行某种酉变换。在上一节中，您已经使用 Qiskit 看到了一些这样的门的例子。本节使用 Cirq [30]探讨类似的见解。

Cirq 是 Google 为量子计算机编程而创建的开源框架。它是“一个 Python 软件库，用于编写、操纵和优化量子电路，然后在量子计算机和量子模拟器上运行它们。”Cirq 为处理当今嘈杂的中等规模量子计算机提供了有用的抽象，其中硬件的细节对于实现最先进的结果至关重要。Cirq 文档位于 [`https://quantumai.google/cirq`](https://quantumai.google/cirq) 。GitHub 直播在 [`https://github.com/quantumlib/Cirq`](https://github.com/quantumlib/Cirq) 。

Cirq 在 Python 3.6.x(本书中首选的 Python 版本)中通过以下命令安装。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig9_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig9_HTML.jpg)

图 4-9

LTS Ubuntu 18.04 上的 Cirq 安装。(`qml`)是虚拟环境名

```py
$ pip3 install cirq

```

图 [4-9](#Fig9) 显示了一个安装过程的例子，其中软件包被安装在一个名为`qml`的虚拟环境中。第 1 章描述了创建虚拟环境的方法。

一旦安装了 Cirq，就从同一个虚拟环境中打开一个 Jupyter 笔记本会话，并通过打印 Google 的`cirq.google.Bristlecone`和`Cirq.ipynb`中的代码来运行清单 [4-2a](#PC11) 中的快速验证测试。Bristlecone 是一台谷歌量子计算机，他们用它实现了量子优势。每个刚毛设计芯片都有 72 个量子位。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figg_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figg_HTML.jpg)

```py
import cirq
import numpy as np
print(cirq.google.Bristlecone)

Listing 4-2aBloch Sphere Simulation in Cirq.ipynb

```

该代码产生图 [4-10](#Fig10) 中的输出，确认 Cirq 安装成功。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig10_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig10_HTML.jpg)

图 4-10

Cirq 中的谷歌刺果酮

该电路由最初在∣0⟩态制备的单个量子位组成，用酉 x 门操作处理，然后在计算基础上再次测量量子位。

清单 [4-2b](#PC12) 显示了定义 X 门的步骤。

```py
# Get a qubit and a circuit
qbit = cirq.LineQubit(0)
circuit = cirq.Circuit()
# Add an X gate: acts like the Pauli Matrix sigma_x
circuit.append(cirq.X(qbit))

Listing 4-2bGenerate a Qubit and a Circuit Cirq.ipynb

```

在清单 [4-2c](#PC13) 中，下一步，我们用`cirq.Simulator()`函数运行模拟。

```py
# Simulation that extracts the wavefunction
sim = cirq.Simulator()
result = sim.simulate(circuit)
print("\nBloch Sphere of the qubit in the final state:")
state = cirq.bloch_vector_from_state_vector(result.final_state,0)
print("x: ", np.around(state[0], 4), " y: ", np.around(state[1], 4)," z: ", np.around(state[2], 4))

Listing 4-2cSimulation of Wave Function Cirq.ipynb

```

该代码生成量子位在其最终状态下的以下 Bloch 定义作为输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figh_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figh_HTML.jpg)

下一步，列出 [4-2d](#PC14) ，为电路添加一个测量门。

```py
# Add a measurement gate at the end of the circuit:
circuit.append(cirq.measure(qbit, key="Final state"))
# Display the circuit:
print("\nCircuit:")
print(circuit)

Listing 4-2dAdd Measurement on X Gate Cirq.ipynb

```

该代码产生以下电路作为输出，显示测量门为 *M* 。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figi_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figi_HTML.jpg)

这个实验的下一步(见清单 [4-2e](#PC15) )使用模拟器并运行十次试验模拟来确定量子位的最终状态。

```py
# Invoke the Cirq quantum simulator to execute the circuit
simulator = cirq.Simulator()
# Simulate the circuit several times:
result = simulator.run(circuit, repetitions=10)
# Print the results:
print("\nResults of 10 trials:")
print(result)

Listing 4-2eRepeated Simulations Cirq.ipynb

```

此代码的输出给出了以下最终状态。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figj_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figj_HTML.jpg)

这个例子使用 Cirq 模拟器的一个用户友好的特性，提取量子最终态波函数。这在真正的量子计算机上通常是不可能的，在量子计算机上你必须多次运行相同的电路才能到达最终状态。在本例中，最后一个州是∣1⟩.

##### 用 Cirq 测量响铃状态

在本练习的前面，您已经在 Qiskit 中遇到了贝尔状态及其定义。您应该熟悉 Cirq 中响铃状态的产生和测量。有可能在计算基础上采用两个量子位的状态，并通过在第一个量子位上使用哈达玛门，然后在一对量子位上使用 CNOT 门，将它们转换成贝尔状态，如下所示。

![$$ \mid 00\left\rangle \Rightarrow \mid 0\right\rangle =\frac{1}{\sqrt{2}}\left(11\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equn.png)

(4.11)

![$$ \mid 01\left\rangle \Rightarrow \mid {\beta}_{01}\right\rangle =\frac{1}{\sqrt{2}}\left(10\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equo.png)

(4.12)

![$$ \mid 10\left\rangle \Rightarrow \mid {\beta}_{10}\right\rangle =\frac{1}{\sqrt{2}}\left(11\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equp.png)

(4.13)

![$$ \mid 11\left\rangle \Rightarrow \mid {\beta}_{11}\right\rangle =\frac{1}{\sqrt{2}}\left(10\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equq.png)

(4.14)

在两个量子位的希尔伯特空间中，方程[4.11](#Equn)–[4.14](#Equq)中所示的幺正变换是从两个量子位计算基到贝尔态基的变换。如果以相反的顺序执行酉运算，则有可能从贝尔基旋转回到计算基。这个逆操作，接着测量量子位，被称为*贝尔态测量*。净效应是使用 EPR 对将两个量子比特的状态投射到四个贝尔态中的一个。电路如图 [4-11](#Fig11) 所示。清单 [4-2f](#PC16) 是启动铃状态测量练习的代码。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig11_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig11_HTML.jpg)

图 4-11

纠缠 EPR 对上的门操作

```py
# Get two qubits and a circuit
qubit = [cirq.LineQubit(x) for x in range(2)]
circuit = cirq.Circuit()
# Add a Hadamard gate to qubit 0, then a CNOT gate from qubit 0 to qubit 1:
circuit.append([cirq.H(qubit[0]),
cirq.CNOT(qubit[0], qubit[1])])
# Run a simple simulation that extracts the actual final states
sim = cirq.Simulator()

result = sim.simulate(circuit)
print("\nBloch Sphere of the qubit 0 in the final state:")
state = cirq.bloch_vector_from_state_vector(result.final_state,0)
print("x: ", np.around(state[0], 4), " y: ", np.around(state[1], 4), " z: ", np.around(state[2], 4))
print("\nBloch Sphere of the qubit 1 in the final state:")
state = cirq.bloch_vector_from_state_vector(result.final_state,1)
print("x: ", np.around(state[0], 4), " y: ", np.around(state[1], 4), " z: ", np.around(state[2], 4))

Listing 4-2fMeasurement on X Gate Cirq.ipynb

```

这个代码片段给出了以下输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figk_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figk_HTML.jpg)

然后，我们在电路中添加一个测量门，与 X 门中的一样。这显示在清单 [4-2g](#PC17) 中。

```py
# Add a measurement at the end of the circuit:
circuit.append(cirq.measure(*qubit, key="Final state"))
# Display the circuit:
print("\nCircuit:")
print(circuit)

Listing 4-2gMeasurement on X Gate Cirq.ipynb

```

以下电路作为输出打印出来，显示测量门为 *M* ，哈达玛门为 *H* 。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figl_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figl_HTML.jpg)

对于 Bell states 练习中的最后一步，我们运行模拟十次，与上一个练习相同。

```py
# Run the Cirq quantum simulator to execute the circuit:
simulator = cirq.Simulator()
# Simulate the circuit several times:
result = simulator.run(circuit, repetitions=10)
# Print the results:
print("\nResults:")
print(result)

Listing 4-2hMeasurement on X Gate Cirq.ipynb

```

输出如下。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figm_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figm_HTML.jpg)

如果清单 4-4h 运行几次，每个量子位的结果随机变化，但是它们在两个量子位之间是 100%相关的。量子模拟器的结果来自最终态的计算基础中的 10 次测量，∣*β*T2】00⟩，这是与爱丽丝和鲍勃相同的 EPR 对态。请注意，Cirq 报告说，两个量子位的最终状态都在布洛赫球的中心，而不是在其表面。

总之，关于 EPR 对，有一些事情需要记住。

*   量子随机性发生在窃听者(比如伊芙)和爱丽丝之间以及伊芙和鲍勃之间，但不发生在爱丽丝和鲍勃之间。

*   当 Alice 和 Bob 接收到相同的二进制位串时，Eve 当时不可能拥有他们的位串。

*   虽然是随机生成的，但它们共享的位串最终会产生很大的因果后果。

这种量子怪异被爱因斯坦称为“超距幽灵行动”

## 熵:经典与量子

熵被宽泛地定义为量化信号中信息的一种方式。简而言之，熵可以被解释为我们对给定系统状态的*不确定性**或*测量系统后我们获得的信息量。

### 香农熵

经典信息的关键概念是香农熵。克劳德·香农熵试图提供与给定状态∣ *ψ* <sub>*i*</sub> ⟩， *i* ∈ {1… *n* }相关联的信号中的信息的统计表示。香农的理论是基于发现看到给定信息的概率。这使得科学家们能够表征从信号中获得的信息量。

Shannon 通过对给定消息的概率取以 2 为底的对数来量化所获得的信息量。如果消息中包含的信息用*ι*表示，其出现的概率用 *p* 表示，那么

T5

其中，负号确保消息的信息内容保持为正。比如今天股市不暴跌 5%以下的概率是 0.9，那么新闻的信息量就是ι= log<sub>2</sub>0.9 = 0.152。

形式上，如果 *x* ∈ { *x* <sub>1</sub> ，*x*<sub>2</sub>…*x*<sub>*n*</sub>}是概率分布为*p*∈{*p*<sub>1</sub>，*p*<sub>2</sub>…

因此，如果给定的 *x* <sub>*i*</sub> 的概率为 0，则香农熵为 0∫log 0 = 0。如果状态是纯的，香农熵估计其最小值为 0，如果是随机的，则取其最大值。状态的混合增加了熵。一般来说，下面的经验法则估计香农熵。

*   如果信息或消息的内容是确定的，那么香农熵为零。

*   下一条信息内容的不确定性越高，香农熵就越高。

换句话说，熵量化了我们测量 *x* 时获得的信息量。被称为*二元熵函数* (BEF)的熵函数示例如图 [4-12](#Fig12) 所示。在信息论中，BEF 被定义为成功概率为 *p* 的伯努利试验的熵。在数学上，伯努利试验被建模为一个随机变量 *x* ，它只能取两个值:0 和 1。事件 *x* = 1 被认为是成功的，而事件 *x* = 0 被认为是失败的，其中两个事件是互斥且穷尽的。

如果 *x* = 1 的概率由*Pr*(*x*= 1)=*p*给出，那么 *x* = 0 的概率由*Pr*(*x*= 0)=(1-T14)p 给出。在他的例子中， *x* 的熵由

![$$ {S}_{SHE}(x)=- pp-\left(1-p\right)\left(1-p\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equt.png)

(4.16)给出

其中对于二元运算，对数通常以 2 为底。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig12_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig12_HTML.jpg)

图 4-12

香农熵的二元熵函数

如图 [4-12](#Fig12) 所示，熵在![$$ p=0.5=\frac{1}{2} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq10.png)时达到最大值。最大熵出现在具有最少知识量的实例中。当每个可能的结果都是同样可能的时，那么离散概率 *p* <sub>* i *</sub> 反映了关于测量结果的最少量的知识。因此，有了 *n* 个可能的结果，每个概率由

![$$ {p}_i=\frac{1}{n} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equu.png)

(4.17)给出

其中![$$ p=\frac{1}{2} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq11.png)的情况是无偏位的情况，无偏位是信息熵最常见的单位。清单 [4-3](#PC19) 显示了用于生成图 [4-12](#Fig12) 中的情节的简单 Python 代码`BinaryEntropyFunction.ipynb`的片段。定义了概率和熵，并基于对数函数生成值以给出熵图。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fign_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fign_HTML.jpg)

```py
# Import Libraries
import matplotlib.pyplot as plt
import math

# Define Probabilities and Entropy Functions
px0 = []
px1 = []
Sx0=[]
Sx1=[]
A=0.99
B=0.01
px0.append(1)
Sx0.append(0)

for i in range(99):
    V = math.log(A,2)
    J = math.log(B,2)
    Sx0.append((-A*V)+(-B*J))
    px0.append(A)
    px1.append(B)

   # Sx1.append(-A*(math.log(A,2)) -B*(math.log(B,2)))
    A -= 0.01
    B += 0.01
px0.append(0)
Sx0.append(0)

# Print the values and the graph
for i in range(20):
    print()
    print("p(x): ",end="")
    for j in range(5):
        print(str(px0[j*i+i])+",",end="")
print()

for i in range(20):
    print()
    print("S(x): ",end="")
    for j in range(5):
        print(str(Sx0[j*i+i])+",",end="")
plt.plot(px0, Sx0, color='blue')
plt.xlabel('P(X)')
plt.ylabel('S(X)')
plt.title('Binary entropy function')
plt.show()

Listing 4-3Libraries and Functions in BinaryEntropyFunction.ipynb

```

从数学上讲，如果 *p* = 0.3，那么找到替代方案的概率就是 1*p*= 0.7。

这表明在测量之前已经知道了状态，因为一个可能的值比另一个更有可能。在这种情况下，参考方程 [4.2](#Equc) ，我们有

![$$ - pp-\left(1-p\right)\left(1-p\right)=-0.3(0.3)-\left(1-0.3\right)\left(1-0.3\right)=0.88 $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equv.png)

另一方面，如果我们有 if *p* = 0.05，备选项的概率为 95%，那么我们得到

![$$ - pp-\left(1-p\right)\left(1-p\right)=0.29 $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equw.png)

结果的完全不确定性意味着所有可能的结果都是同样可能的。一般规律是熵越大，测量前结果的不确定性越大。

### 冯·诺依曼熵

一个*量子态*的熵值是由香农熵的一个类似物决定的。这是通过使用密度算子而不是方程 [4.1](#Equb) 中的概率分布元素来实现的。*量子信息理论*与经典理论有些相似，因为信息是由*量子系统携带的。因此，这是有区别的，因为量子位在不止一种意义上携带信息。*

*   经典比特可以被编码成量子比特。

*   由于不可克隆定理或可分辨性的限制，未知量子位可以携带隐藏和保护的信息。

如果我们回忆一下等式 [1。29](1.html#Equak) 在第 [1](1.html) 章中，混合量子系统的密度算符如下。

![$$ \rho ={\sum}_{i=1}^n{\rho}_i{p}_i={\sum}_i^n{p}_i\mid {\psi}_i\left\rangle \right\langle {\psi}_i\mid $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equx.png)

(4.18)

其中∣*ψ*T2】T3】It5】⟩代表混合量子系统中一个系综中的 *n* 个可能态， *p* <sub>*i*</sub> 是一个成员处于相应态的概率∣*ψ*<sub>*I*</sub>⟩.

回想一下，密度算符是一种描述量子系统可能状态的方式，或者等效地说，是一种描述可能测量结果的方式，与概率分布非常相似。具有密度算符 *ρ* 的量子态的熵称为*冯诺依曼熵*，由

![$$ S\left(\rho \right)=- Tr\left(\rho \rho\ \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equy.png)

(4.19)给出

其中 *Tr* 描绘了密度算子的轨迹。

在具有密度态 *ρ* 和 *ϵ* 的混合系统中，*相对冯诺依曼熵*由

![$$ S\left(\rho |\epsilon \right)= Tr\left(\rho \rho\ \right)- Tr\left(\rho \epsilon\ \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equz.png)

给出(4.20)

一般情况下，*s*(*ρ*|*ϵ*)≥0。只有当 *ρ = ϵ* 时才相等。

如果密度算符的特征值由*λ*<sub>T3】IT5】给出，那么冯诺依曼熵由</sub>

![$$ S\left(\rho \right)=-{\sum}_i{\lambda}_i{\lambda}_i $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaa.png)

给出(4.21)

一般来说，在 *n* 维中，量子态的熵遵循不等式。

![$$ n\ge S\left(\rho \right)\ge 0 $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equab.png)

(4.22)

量子系统中的复合态通常是由量子位态的张量积形成的态。如果一个复合态是可分的，那么它就形成了一个形式为 *ρ* ⊗ *ϵ* 的乘积态。在这种情况下，熵是可加的，由

![$$ S\left(\rho \otimes \epsilon\ \right)=S\left(\rho \right)+S\left(\epsilon \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equac.png)

(4.23)给出

一般来说，熵是次可加的。换句话说，复合系统的简化密度矩阵由不等式

![$$ S\left({\rho}_{12}\right)\le S\left({\rho}_1\right)+S\left({\rho}_2\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equad.png)

(4.24)给出

方程 [4.10](#Equm) 表明，要获得关于一个纠缠系统的最多信息，我们需要考虑*整个*系统；也就是说， *S* ( *ρ* )小于简化密度矩阵的组合熵，因为当考虑整个系统时知识增加了。拥有简化密度矩阵*ρ*T10】1 和*ρ*2<sub>2</sub>的用户在仅考虑系统的部分时对状态的了解较少。

### 状态的演变

由于它们固有的性质，在量子物理中，系统的状态通常随时间演化。在量子计算的电路和门模型中，状态按照*酉矩阵运算*演化(参见 [1 章](1.html))。状态向量的演化相当于执行线性代数。在量子退火平台上，使用*哈密顿量*来模拟状态的演化(参见第 [1 章](1.html))。有两种重要的状态:混合态和纯态。*纯态*具有这样的性质:它们总是可以被表示为一个状态向量与其自身的*外积*。*混合状态*一般表示为正交状态向量的和。在纯态下，冯·诺依曼熵永远为零，类似于确定性的香农熵。在混合态中，熵可以用一系列值来表示。

冯·诺依曼熵的性质可以总结如下。

1.  *S* ( *ρ* ) = 0 当且仅当 *ρ* 为纯态。

2.  对于![$$ \mathit{\dim}\left(\mathbf{\mathcal{H}}\right)=N $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq12.png)(希尔伯特空间的维数)，*S*(*ρ*)= log*N*给出了 *S* ( *ρ* )对于*最大混合态*的最大值。

3.  *S* ( *ρ* )在基变化下不变(即*S*(*ρ*)=*S*(*UρU*<sup>)对于任何酉矩阵 *U* )。</sup>

4.  For a set of numbers {*λ*<sub>*i*</sub>} such that and *λ*<sub>*i*</sub> > 0, and for a corresponding collection of density matrices {*ρ*<sub>*i*</sub>} we have

    ![$$ S\left(\sum \limits_i{\lambda}_i{\rho}_i\right)&gt;\sum \limits_i{\lambda}_iS\left({\rho}_i\right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equae.png)

5.  For a set of numbers, *S*(*ρ*) satisfies

    ![$$ S\left(\sum \limits_i{\lambda}_i{\rho}_i\right)\le \sum \limits_i{\lambda}_iS\left({\rho}_i\right)-\sum \limits_i{\lambda}_i\log {\lambda}_i $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaf.png)

6.  *s*(*ρ*<sub>*m*</sub>⊗*ρ*<sub>*n*</sub>)=*s*(*ρ*<sub>*m*</sub>)+*s*(*ρ**n*)为独立

7.  *s*(*【123】)+*(*)≤T12】***

****   *s*(**)≤T6*(*+***** 

 ***一个系统从纯状态发展到混合状态，然后又恢复到纯状态的实例可能有助于理解这个过程。在这个过程中，冯·诺依曼熵先增大，然后逐渐减小回到零。

第一步，我们定义自旋向上和自旋向下的状态向量以及由外积给出的纯态。这显示在清单 [4-4a](#PC20) 中。这些库可以在`qiskitStateEvo.ipynb,`Jupyter 笔记本代码示例中找到，其中*提供了完整的代码和额外的示例*。我们用 Qiskit 来探索态的量子演化。

为了开始一些编码，我们调用`qiskit`库来展示 GHZ 状态。`Qiskit`是一个 Python 库，它创建量子电路，并在模拟器或 IBM 的量子设备上运行它们。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figo_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figo_HTML.jpg)

```py
import numpy as np
from qiskit import *
import math as m
from scipy import linalg as la
%matplotlib inline

# Spin-up
u = np.matrix([[1],
               [0]])
# Spin-down
d = np.matrix([[0],
               [1]])
# Pure state |0><0|
P11 = np.dot(u, u.H)
# Pure state |1><1|
P22 = np.dot(d, d.H)

Listing 4-4aSpin-up, Spin-down Definition at qiskitStateEvo.ipynb

```

使用`qiskitStateEvo.ipynb.`中的清单 [4-4b](#PC21) 绘制状态演变图

```py
import matplotlib.pyplot as plt
p = np.arange(0.001, 1., 0.01)

# create list of von Neumann entropies
vn_y = list()
for value in p:
    rho_p = value*P11 + (1-value)*(P22)
    vn_y.append(von_neumann_entropy(rho_p))

# convert list of matrices to list of nos. for plotting
y = list()
for value in vn_y:
    y.append(value.tolist()[0][0])

# plot p vs. S(rho_p)
plt.xlabel('p')
plt.ylabel('von Neumann Entropy')
plt.title('S(rho_p)')
plt.plot(p, y, color='tab:red')
plt.show()

Listing 4-4bvon Neumann Definiton in qiskitStateEvo.ipynb

```

清单 [4-4b](#PC21) 的输出如图 [4-13](#Fig13) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig13_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig13_HTML.jpg)

图 4-13

冯·诺依曼熵

图 [4-13](#Fig13) 的冯诺依曼图和图 [4-12](#Fig12) 的经典香农熵之间的比较表明，它们非常相似。

冯诺依曼熵的单参数密度矩阵族如清单 [4-4c](#PC22) 所示。

```py
# Define spin-up
u = np.matrix([[1],
               [0]])

# Define spin-down
d = np.matrix([[0],
               [1]])

# Define the pure state |0><0|
P11 = np.dot(u, u.H)

# Define the pure state |0><1|
P12 = np.dot(u, d.H)

# Define the pure state |1><0|
P21 = np.dot(d, u.H)

# Define the pure state |1><1|
P22 = np.dot(d, d.H)

# Define the mixed state |0><0| + |1><1|
I = (P11+P22)/2

# Define the pure state |0><0|+|0><1|+|1><0|+|1><1|
D = (P11+P12+P21+P22)/2

p = np.arange(0.001, 1., 0.01)

# Create list of von Neumann entropies
vn_y = list()
for value in p:
    rho = value*I + (1-value)*(D)
    vn_y.append(von_neumann_entropy(rho))

# list of matrices to list of numbers for plotting
y = list()
for value in vn_y:
    y.append(value.tolist()[0][0])

# plot p vs. S(rho_p)
plt.xlabel('p')
plt.ylabel('von Neumann Entropy')
plt.title('S(rho_p)')
plt.plot(p, y, color='tab:blue')
plt.show()

Listing 4-4cOne-Parameter Family in qiskitStateEvo.ipynb

```

清单 [4-4c](#PC22) 产生如图 [4-14](#Fig14) 所示的输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig14_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig14_HTML.jpg)

图 4-14

单参数密度矩阵的冯·诺依曼熵

#### GHZ 状态

在量子信息理论中，GHZ 态代表 green Berger-Horne-zei linger 态，由 Daniel Greenberger、Michael Horne 和 Anton Zeilinger 于 1989 年首次研究[29]。它是一种特定类型的纠缠量子态，涉及两个以上的子系统(例如，粒子态或量子位)。GHZ 态是最大纠缠量子态。对于由 *n* 个子系统组成的系统，每个子系统都是二维的(即量子位)，GHZ 状态由

![$$ \mid GHZ\Big\rangle =\frac{\mid 0\left\rangle {}^{\otimes n}+\mid 1\right\rangle {}^{\otimes n}}{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equag.png)

(4.25)给出

三量子比特 GHZ 态是最简单的一种。它表现出非平凡的多体纠缠。

![$$ \mid GHZ\Big\rangle =\frac{\mid 000\left\rangle +\mid 111\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equah.png)T2】

GHZ 状态是所有处于状态 0 的子系统的量子叠加，所有子系统都处于状态 1，其中单个子系统的状态 0 和 1 是完全可区分的。

使用量子电路可以制备 1 GHZ。清单 [4-4d](#PC23) 是 Jupyter 笔记本`qiskitStateEvo.ipynb.`中的 Qiskit 代码片段

```py
from qiskit import *
import numpy as np
%matplotlib inline

qr = QuantumRegister(3)
cr = ClassicalRegister(3)
GHZ = QuantumCircuit(qr, cr)

GHZ.h(0)
GHZ.cx(0,1)
GHZ.cx(1,2)
GHZ.draw(output='mpl')

Listing 4-4dGHZ in qiskitStateEvo.ipynb

```

清单 [4-4d](#PC23) 给出了 GHZ 输出的量子电路，如图 [4-15](#Fig15) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig15_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig15_HTML.jpg)

图 4-15

GHZ 量子电路

清单 [4-4e](#PC24) 中 Qiskit 的`Statevector()`函数打印状态向量。状态向量用于使用 Qiskit 中的`entropy()`函数获得相应密度矩阵的冯诺依曼熵。Qiskit 中的`DensityMatrix()`函数被传递给`GHZ_state` ket 向量。

```py
backend = Aer.get_backend('statevector_simulator')
GHZ_state = execute(GHZ,backend).result().get_statevector()
print(np.matrix(GHZ_state).H)

from qiskit.quantum_info import Statevector
psi = Statevector(GHZ_state)
print(psi)

Listing 4-4eStatevector in qiskitStateEvo.ipynb

```

现在可以使用 Qiskit `entropy()`函数计算冯诺依曼熵。这可以通过`Statevector`函数或`DensityMatrix`函数传递。在后一种情况下，输出实际上是零熵，而在第一种情况下，它正好是零。这是有意义的，因为态是纯态，密度矩阵计算为*d*=∣*ψ*⟩⟨*ψ*|。

值得注意的是在达到最终混合状态之前的中间时间点的最大值。一般来说，熵会随着时间的推移而增加。然而，在可以行使实质性控制的有效“封闭”量子系统中，熵可以降低到更低的水平(见清单 [4-4f](#PC25) )。

```py
from qiskit.quantum_info import entropy
vn_entropy1 = entropy(psi, base=2)
vn_entropy2 = entropy(D, base=2)
print(vn_entropy1)

Listing 4-4fEntropy in qiskitStateEvo.ipynb

```

下面显示清单 [4-4f](#PC25) 的输出为 0。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figp_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figp_HTML.jpg)

从 GHZ 态的密度矩阵 *D* 给出的态演化到密度矩阵 *ρ* 描述的系统的熵可以通过列出 [4-4g](#PC26) 来计算。

```py
from qiskit.quantum_info import random_density_matrix
rho = random_density_matrix(8, rank=None, method='Hilbert-Schmidt', seed=None)
print(rho)

time = np.arange(0.001, 1., 0.01)

vn_entropy = list()
for t in time:
    vn_entropy.append(entropy(D, base=2)*t + entropy(rho, base=2)*(1-t))

# Create list of von Neumann entropies
vn_y = list()
for value in p:
    M = value*rho + (1-value)*(D)
    vn_y.append(entropy(M))

# plot p vs. S(rho_p)
plt.xlabel('time')
plt.ylabel('von Neumann Entropy')
plt.title('S(rho(t))')
plt.plot(p, vn_y, color='tab:blue')
plt.show()

Listing 4-4gEntropy Calculation of Evolved State in qiskitStateEvo.ipynb

```

输出曲线如图 [4-16](#Fig16) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig16_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig16_HTML.jpg)

图 4-16

演化 GHZ 系统的熵

在图 [4-16](#Fig16) 中，最大值出现在中间时间点，就在达到最终混合状态之前。一般来说，熵会随着时间的推移而增加。然而，在有效封闭的量子系统中，可以进行实质性的控制，熵可以降低到较低的水平。

## 再论不克隆定理

第[章 1](1.html) 讨论了量子力学的*不可克隆定理*，该定理指出量子态不能通过门操作等幺正变换直接复制或克隆。这意味着如果∣ *ψ* ⟩是一个量子态，而 *U* 是某种幺正变换，使得*u*∣*ψ*0⟩=∣*ψψ*⟩，那么这个性质不可能适用于任意态∣ *ψ* ⟩.该理论源于两个正交态(如单量子位情况下的∣0⟩和∣1⟩)和一个 *U* 的线性量子叠加的可能性，使得*u*∣*ψ*0⟩=∣*ψ♀*⟩和*u*∣*ϕ*0÷=∣*9 如果我们考虑叠加![$$ \mid \varphi \Big\rangle =\frac{1}{\sqrt{2}}\left(|\psi \Big\rangle +|\phi \Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq13.png)，那么*

*![$$ U\mid \varphi 0\Big\rangle =\frac{1}{\sqrt{2}}\left(U|\psi 0\Big\rangle +U|\phi 0\Big\rangle \right)=\frac{1}{\sqrt{2}}\left(|\psi \psi \Big\rangle +|\phi \phi \Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equai.png)*

*(4.26)*

![$$ \mid \varphi \varphi \Big\rangle =\frac{1}{\sqrt{2}}\left(|\psi \psi \Big\rangle +|\psi \phi \Big\rangle +|\phi \psi \Big\rangle +|\phi \phi \Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaj.png)

(4.27)

从方程 [4.26](#Equai) 和 [4.27](#Equaj) 我们看到

![$$ \left|\varphi \varphi \Big\rangle \ne U\right|\varphi 0\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equak.png)

(4.28)

本质上，不可克隆定理规定我们不能复制一个未知的量子态。然而，这并没有对复制一个已知的*量子态施加任何限制。的确，*这样做应该是可能的；实际上，它说我们可以准备同一个已知状态的许多相同的副本。不可复制定理对量子通讯有重大的影响，因为它暗示了要建构一个保存任意量子资讯的放大器是不可能的。不可克隆定理也使黑客无法复制信息和违反安全。

## 量子隐形传送

量子隐形传态是一个过程，通过这个过程，一个量子比特状态可以通过只发送两个经典比特的信息来传输。这个选项的工作原理是分发纠缠的量子粒子。这些纠缠在一起的粒子，一旦以可控的方式分布在两端，就产生了虚拟通道。

如图 [4-17](#Fig17) 所示，量子隐形传态是一种利用 EPR(爱因斯坦-波多尔斯基-罗森)源的纠缠贝尔对的现象[32]。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig17_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig17_HTML.jpg)

图 4-17

带测量电路的量子隐形传态

图 [4-17](#Fig17) 所示的电路是带测量的量子隐形传态*，初始状态为∣000⟩；通过应用 X 和 Y 门的随机幂，消息量子位被转换成非平凡状态。Alice 和 Bob 量子比特纠缠在一起成为 EPR 对。对消息和 Alice 量子位执行 Bell 测量。来自这个测量的经典信息然后控制 Bob 量子位上的两个单量子位操作。过程如下。*

*   发送者爱丽丝将一对纠缠粒子中的一个粒子发送到目的地，同时保留另一个粒子作为源。

*   对于一个窃听者 Eve 来说，*不可克隆定理*认为在不破坏纠缠粒子状态的情况下观察和测量它是不可能的。一旦她测量了一个特定的状态，测量的行为就会导致这个状态崩溃。换句话说，Eve 没有办法破坏安全。量子纠缠的这个特性使它成为一个安全的 T2 通道。

*   理论上，不仅纠缠对的安全性很高，而且一对粒子也可以不受距离的影响而保持纠缠，甚至在宇宙尺度上。在实验中，量子纠缠已经被证明在空间和地球之间的距离达到大约 1200 公里，在地面实验中达到 50 公里[33]。

*   接收器 Bob 需要一个经典的开放信道来有效地解码量子数据，为此提出了 Eckert91 [34]类型的纠缠以确保严格的安全性。

*   爱丽丝首先通过量子通道将纠缠的量子比特∣*b*T2】1⟩传送给鲍勃。

图 [4-15](#Fig15) 中的量子位 2 和 3 是 Bell 态的纠缠 EPR 对。

![$$ \mid {B}_{00}\Big\rangle =\frac{\mid 00\left\rangle +\mid 11\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equal.png)

(4.29)

*   方程 [4.25](#Equag) 中的∣*b*T2】00⟩有下标 00，表示按照惯例，所有量子位都在∣0⟩.状态初始化

*   Figure [4-15](#Fig15) shows the three-qubit state in five characteristic points of a quantum circuit. The input three-qubit state at point A is given by

    ![$$ \mid {\psi}_A\Big\rangle =\frac{\mid x00\left\rangle +\mid x11\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equam.png)

    (4.30)
*   The first qubit is used as a control qubit, and the second qubit is the target qubit for the CNOT (Control-X) gate. Therefore, the state at point B becomes,

    ![$$ \mid {\psi}_B\Big\rangle =\frac{\mid xx0\left\rangle +\mid x\left(1-x\right)1\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equan.png)

    (4.31)
*   The Hadamard gate (*H*) performs mapping on the first qubit.

    ![$$ H\mid x\Big\rangle =\frac{\mid 0\left\rangle +{\left(-1\right)}^x\mid 1\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equao.png)

    (4.32)
*   The state at point C is given by

    ![$$ \mid {\psi}_C\Big\rangle =\frac{\mid 0x0\left\rangle +{\left(-1\right)}^x\mid 1x0\right\rangle +\mid 0\left(1-x\right)1\left\rangle +{\left(-1\right)}^x\mid 1\left(1-x\right)1\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equap.png)

    (4.33)
*   The second qubit is used as a control qubit. The third is a target qubit in the CNOT gate. The quantum state at point D is given by

    ![$$ \mid {\psi}_D\Big\rangle =\frac{\mid 0 xx\left\rangle +{\left(-1\right)}^x\mid 1 xx\right\rangle +\mid 0\left(1-x\right)x\left\rangle +{\left(-1\right)}^x\mid 1\left(1-x\right)x\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaq.png)

    (4.34)
*   Finally, the state at point E is given by the following. (The first qubit is used for control and the third as the target for the controlled-Z gate.)

    ![$$ \mid {\psi}_E\Big\rangle =\frac{\mid 0 xx\left\rangle +\mid 1 xx\right\rangle +\mid 0\left(1-x\right)x\left\rangle +\mid 1\left(1-x\right)x\right\rangle }{\sqrt{2}} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equar.png)

    (4.35)

![$$ =\frac{\mid 0x\left\rangle +\mid 1x\right\rangle +\mid 0\left(1-x\right)\left\rangle +\mid 1\left(1-x\right)\right\rangle }{\sqrt{2}}\otimes \mid x\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equas.png)

(4.36)

*   作为最后一步，对前两个量子位进行测量，这两个量子位被销毁，第三个量子位被传送到接收器。

*   目的地和源量子位之间的比较提供了正确的量子态被传送的结论。这种分析没有考虑量子通道引入的任何误差。

注意，传送状态是*而不是叠加*状态。因此，任何任意态的∣*b*T4】1⟩都可以通过图 [4-15](#Fig15) 方案进行隐形传送。Alice 测量她的侧信道数据，并通过经典信道将其发送给 Bob。鲍勃使用图 [4-15](#Fig15) 中经典控制的泡利 X(或 CNOT)和 Z 门重建量子数据。这种情况本质上是安全的，因为

*   测量改变了纠缠粒子的状态。

*   攻击者需要访问量子和经典通道才能成功解码。

这部分是关于 Cirq 的实践课程，看看传送是如何工作的。编码练习表明，鲍勃量子位的最终状态保证是消息量子位最初所处的任何状态。这只有在 Alice 和 Bob 之间预先共享纠缠态的情况下才是可能的。

在下面的练习中，通过应用 X 和 Y 门，在随机状态下准备消息(量子位 0)。Alice 拥有消息量子位和量子位 1，量子位 1 是带有 Bob 的量子位 2 的 EPR 对的一部分。爱丽丝现在对她的一对量子位元进行贝尔态测量，得到四种可能的结果之一。然后，她将相当于两个经典比特的结果传输给 Bob。Bob 对他的量子位执行酉运算，这取决于他从 Alice 收到的信息。

在清单 [4-5a](#PC27) 中，继续我们之前的 Cirq 练习，三个量子位、Hadamard 门和测量被定义为形成隐形传态电路，如代码体中所评论的。

```py
import random
# Define three qubits: msg = qubit[0], qalice = qubit[1], qbob = qubit[2]
qubit=[0]*(3)
qubit[0] = cirq.NamedQubit('msg')
qubit[1] = cirq.NamedQubit('qalice')
qubit[2] = cirq.NamedQubit('qbob')
circuit = cirq.Circuit()
# Create a Bell state entangled pair to be shared between Alice and Bob.
circuit.append([cirq.H(qubit[1]), cirq.CNOT(qubit[1], qubit[2])])
# Creates a random state for the Message.
ranX = random.random()
ranY = random.random()
circuit.append([cirq.X(qubit[0])**ranX, cirq.Y(qubit[0])**ranY])

# Unitary operator rotating the two-qubit basis of the Message and Alice's entangled qubit;
# rotates the Bell state basis to the computational basis:
circuit.append([cirq.CNOT(qubit[0], qubit[1]), cirq.H(qubit[0])])
# Combining now with a measurement in the computational basis,
# we effectively have projected this two-qubit state onto one of the four states of
# the Bell state basis:

circuit.append(cirq.measure(qubit[0], qubit[1]))

Listing 4-5aTeleporation Circuit Definition Cirq.ipynb

```

下面使用来自贝尔测量的两个经典比特来恢复。

```py
# Use the two classical bits from the Bell measurement to recover the
# original quantum Message on Bob's entangled qubit.
circuit.append([cirq.CNOT(qubit[1], qubit[2]), cirq.CZ(qubit[0], qubit[2])])
print("Circuit:")
print(circuit)

Listing 4-5bRecover Original Message in Bob’s Entangled Qubit Cirq.ipynb

```

这就给出了下面的隐形传态电路作为输出，类似于图 [4-17](#Fig17) 。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figq_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figq_HTML.jpg)

下一步类似于上一个关于贝尔状态的练习。我们管理 cirq。Simulator()来定义创建消息并输出 Bloch 球体位置的门(参见清单 [4-5c](#PC29) )。

```py
sim = cirq.Simulator()
# Simulation that applies the random X and Y gates to
# create the message.
q0 = cirq.LineQubit(0)
message = sim.simulate(cirq.Circuit([cirq.X(q0)**ranX, cirq.Y(q0)**ranY]))
print("\nBloch Sphere of the Message qubit in the initial state:")
expected = cirq.bloch_vector_from_state_vector(message.final_state,0)
print("x: ", np.around(expected[0], 4), " y: ", np.around(expected[1], 4), " z: ", np.around(expected[2], 4))

Listing 4-5cBloch Sphere Output Cirq.ipynb

```

例如，如果代码运行多次，输出结果可能会发生变化。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figr_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figr_HTML.jpg)

![img/502577_1_En_4_Chapter/502577_1_En_4_Figs_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figs_HTML.jpg)

这种行为是量子力学概率性质的直接结果。

最后一步是找到最终状态的布洛赫球，如清单 [4-5d](#PC30) 所示。

```py
# Records the final state of the simulation.
final_results = sim.simulate(circuit)
print("\nBloch Sphere of Bob's qubit in the final state:")
teleported = cirq.bloch_vector_from_state_vector(
final_results.final_state, 2)
print("x: ", np.around(teleported[0], 4), " y: ",
np.around(teleported[1], 4), " z: ", np.around(teleported[2], 4))
print("\nBloch Sphere of the Message qubit in the final state:")
message_final = cirq.bloch_vector_from_state_vector(
final_results.final_state, 0)

print("x: ", np.around(message_final[0], 4), " y: ", np.around(message_final[1], 4), " z: ", np.around(message_final[2], 4))

Listing 4-5dBloch Sphere of the Final state Cirq.ipynb

```

最终输出给出了如下的布洛赫状态。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figt_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figt_HTML.jpg)

如果程式码执行几次，就很清楚讯息量子位元的最终状态永远不是∣0⟩就是∣1⟩，这是微不足道的，也是不可复制定理的表现。《星际迷航》的粉丝可能还记得，这就是为什么麦考伊博士反对在星舰企业号上使用传送装置，因为传送过程似乎会破坏原始信息，然后在其他地方瞬间重新创建！

我们进行测量的量子隐形传态电路的变体是相同的电路，但是没有测量。如清单 [4-5e](#PC31) 所示，计算基础中省略了量子位 0 和 1 的测量。

```py
# Unitary operator rotating the two- qubit basis of the Message and Alice's entangled qubit;
# rotates the Bell state basis to the computational basis:
circuit.append([cirq.CNOT(qubit[0], qubit[1]), cirq.H(qubit[0])])
# This time skip the measurement
# circuit.append(cirq.measure(qubit[0], qubit[1]))
# Use the same operations as before to recover the
# original quantum Message on Bob's entangled qubit.
circuit.append([cirq.CNOT(qubit[1], qubit[2]), cirq.CZ(qubit[0], qubit[2])])

Listing 4-5eTeleportation Without Measurement

```

没有测量的传送*和有测量*的*一样有效。这是延迟测量*的*原理的体现，它意味着测量一个量子位的操作与使用它作为受控门操作的控制的操作互换。*

隐形传态的基本工作方式包括用一个经典的通信通道来代替部分交换，这使得鲍勃的量子位可以任意远离爱丽丝的量子位。目前，传送的速度只受到一个事实的限制，即经典信息的传输速度不能超过光速。鲍勃可以选择在接收到来自爱丽丝的经典传输之前测量他的量子位，因为有 25%的时间，他已经有了正确的量子状态，而无需执行任何“校正”当爱丽丝的信息最终出现时，鲍勃知道他传送的信息是否有效。

远距离量子隐形传态不再是实验室里的思想实验。费米实验室与加州理工学院和美国电话电报公司合作，正在调试一个高保真、高速率的量子隐形传态系统，该系统使用近红外光子在标准电信光纤上移动，将两个时间仓叠加作为量子位。其他国家实验室正在开发类似的系统(见 Joe Lykken 课堂笔记[35])。

## 闸门调度

在我们深入第五章[的量子算法的复杂性之前，让我们先解决一些大多数量子算法所基于的基础知识。本节介绍门调度和相关主题的指令级优化。对*逻辑*量子位的一系列门操作被称为*时间表*。*逻辑*量子位由一个或多个*物理*量子位组成，可以叠加，被认为比物理量子位有更多的相干时间。*物理*量子位是量子位的实际量子实现*物理实现*如电子或原子。就今天的技术水平而言，物理量子位面临着不完美和一致性的挑战。当前物理构建的多量子位系统的局限性可以通过从几个不完美的物理量子位构建一个逻辑量子位来克服。逻辑量子位可以用于编程，并可以由运行在台式机或笔记本电脑上的普通 CPU 上的模拟器来实现，以允许量子算法的开发、测试和调试。](5.html)

量子电路的门之间有*数据依赖*。门控*序列排序*定义了门控之间数据相关性。对于图 [4-18](#Fig18) 中具有量子位 q1、q2 和 q3 的电路，如果它们共享一个逻辑量子位，门 G2 依赖于门 G1。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig18_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig18_HTML.jpg)

图 4-18

门控序列

一个量子位一次只能参与一个量子门。由于量子电路从左到右执行，数据相关性决定了量子电路中门的*顺序*和*并行*执行的顺序。背对背的两个顺序门通常具有明确定义的排序约束，换句话说，

![img/502577_1_En_4_Chapter/502577_1_En_4_Figu_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figu_HTML.jpg)

如果门 A 和 B 都是任意的酉运算符，那么交换它们出现的顺序通常会产生不同的结果。在一些特殊情况下，酉矩阵有时可以排序，即使不总是等价的。在这些情况下，他们被认为是*相互交换*。

一般两个并排的*平行浇口*没有排序约束。在基于门的量子电路中，门调度的影响可能非常显著。许多算法的实现依赖于并行执行门来实现非平凡的加速。

量子算法中的门调度不同于它们的经典对应物，因为门调度为用户提供了额外的自由度。与经典指令调度相比，量子门调度的研究相对较少，提出的系统方法较少，因此，量子门调度是当前活跃研究的主题，试图找到更新的约束。

## 量子并行性和函数评估

量子算法的基本原理始于*量子并行*。量子并行性是许多量子算法的基本特征。在许多使用函数的情况下，重点是找到函数的结果。然而，在函数的特征或性质比函数评估更重要的情况下，量子算法比它们的经典部分更有优势。量子并行性允许量子计算机同时对 *x 的许多不同值*评估一个函数 *f* ( *x* )。换句话说，量子计算机可以在叠加态下对 *f* ( *x* )的各种值进行求值。

如果 *f* ( *x* )是一个以单比特为输入，单比特为输出的函数，那么 *f* ( *x* )就称为一个*二元函数*。因此，该函数只对 0 和 1 进行运算，其结果也是 0 或 1。

要定义函数，让，

![$$ f(x)=\Big\{0\kern1em when\ x=0\ 1\kern1em when\ x=1 $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equat.png)

比如恒等函数 *f* ( *x* ) = 0 当 *x* = 0 和 *f* ( *x* ) = 1 当 *x* = 1 和常数函数 *f* ( *x* ) = 0 和 *f* ( *x* ) = 1。位翻转函数也属于同一类: *x* = 0 时*f*(*x*)= 1*x*= 1 时 *f* ( *x* ) = 0。

身份和位翻转功能也被称为*平衡*，因为它们的输出在一半输入中是相反的。当 *f* (0) = *f* (1)时，该函数称为*常数，*而当*f*(0)<sup>-1</sup>=*f*(1)时，该函数称为*平衡*。注意，陈述*x*→*f*(*x*)的运算通常不是酉运算，因此不适合量子计算。

一般情况下，给定一个函数的输出 *f* ( *x* )，并不总是可以反相 *f* ( *x* )得到输入 *x* 。换句话说， *f* ( *x* )的计算方式必须保证计算可以撤销。为了解决这个问题，第一个任务是将这些功能建模为量子电路。然而，我们不能简单地将任何门应用于一个量子位，因为根据量子力学的假设，所有的量子操作必须是*酉*和*可逆*(参见第 [1 章](1.html))。

可逆幺正变换如图 [4-19](#Fig19) 所示。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig19_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig19_HTML.jpg)

图 4-19

酉变换(来源[35])

图 [4-19](#Fig19) 显示了酉变换，其中一个假想的酉变换*U*<sub>T5】f</sub>作用于两个量子位，使得

![$$ {U}_f\mid x,y\left\rangle =\mid x,y\oplus f(x)\right\rangle, x,y\in \left\{0,1\right\} $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equau.png)

(4.37)

对方程 [4.37](#Equau) 的解释表明，第一量子位保持不受*U*<sub>T5】f</sub>作用的影响。而第二量子位经受*异或*运算(由⊕算子给出)。

对于初始值 *y* = 0，我们从方程 [4.37](#Equau) 得到如下。

![$$ {U}_f\mid x,0\left\rangle =\mid x,f(x)\right\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equav.png)

我们可以证明*U*<sub>T3】fT5】是可逆的。如果我们再次对其输出应用 *U* <sub>*f*</sub> ，我们得到</sub>

![$$ {U}_f\mid x,\left(y\oplus f(x)\right)\left\rangle =\mid x,\left(y\oplus f(x)\right)\oplus f(x)\right\rangle =\mid x,y\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaw.png)

这里我们使用了模 2 特性，即*f*(*x*)⊕*f*(*x*)= 0(注意:模 2 运算状态:将相同的位相加两次并除以二，余数为零)。

请注意，我们将 *U* <sub>*f*</sub> 视为“黑盒”或“神谕”(即 *U* <sub>*f*</sub> 的内部细节与我们无关。一位先知描述了一个“量子黑盒”，我们假设我们可以实现和运行它，但不能“检查内部”来查看它的实现细节。在内部， *U* <sub>*f*</sub> 由一个或多个量子门组成，甚至可能是一个电路，但我们通常不知道是哪些门或哪种电路。通过查询甲骨文(例如，通过发送输入和测量输出)，我们可以了解更多关于甲骨文的属性。因为预言是由量子门组成的，所以预言本身也需要是可逆的。

现在我们已经建立了算法的基础，可以解释量子并行性的基本原理了。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig20_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig20_HTML.jpg)

图 4-20

量子并行电路

1.  Starting with two qubits at initial state |0⟩, as shown in Figure [4-20](#Fig20), we apply a Hadamard gate to the first qubit. This gives us

    ![$$ H\mid 0\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equax.png)

1.  The second qubit, also at initial state ∣0⟩, after the unitary transformation gives the final state ∣*ψ*<sub>*f*</sub>⟩.

    ![$$ \mid {\psi}_f\left\rangle ={U}_f\mid H\left|0\Big\rangle \right|0\right\rangle \left\rangle ={U}_f\right(\frac{1}{\sqrt{2}}\left(\left|0\Big\rangle +|1\left\rangle \right)\right|0\Big\rangle \right)=\frac{1}{\sqrt{2}}\left({U}_f|00\Big\rangle +{U}_f|10\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equay.png)

![$$ =\frac{1}{\sqrt{2}}\left(|0,0\oplus f(0)\Big\rangle +|1,0\oplus f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equaz.png)T2】

从检查结果可以清楚看出，图 [4-19](#Fig19) 的电路同时包含了 *f* (0)和 *f* (1)的信息；换句话说，电路已经产生了一个叠加状态，该状态在一个单一步骤中具有关于 *f* (0)和 *f* (1)的信息。我们有所谓的*量子并行性*——在一次操作中同时获得两种状态的信息。

量子并行的例子表面上看起来很酷。但是，如果我们停下来想一想我们是如何获得任何信息的，比如这个系统的测量值，我们会看到一个迫在眉睫的问题:如果我们测量状态![$$ {\sum}_0^1\mid x\mid f(x)\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq14.png)，那么我们只获得一个值 *x* 和 *f* ( *x* )作为计算基础。在我们执行测量之后，我们获得的函数值是随机值 *x* 。因此，这个操作本身并不能提供非常有用的结果，因为我们甚至不能选择我们希望显示哪个值: *f* (0)或 *f* (1)。这就是 Deutsch 算法变得重要的地方。

### 多伊奇算法

平衡函数和常数函数已在上一节中描述。然而，找出一个函数是否确实是常数或平衡的往往是一个挑战！为了回答这个问题，大卫·多伊奇在 1985 年提供了一个很好的概念证明:在某些情况下，量子计算机比经典计算机更强大。Deutsch 算法[37]可以简单地用下面的框架来表述。

1.  确定 *f* (0) ⊕ *f* (1)的奇偶性值，其中⊕表示模 2 加法或*异或*运算；也就是说，1 ⊕ 1 = 0 ⊕ 0 = 0，1 ⊕ 0 = 0 ⊕ 1 = 1。

2.  证明如果 *f* ( *x* )为*常数*那么奇偶性为 0，如果 *f* ( *x* )为*平衡*，那么奇偶性为 1。

Deutsch 算法试图解决哪个/哪些给定函数是常数或平衡的。平衡和常数函数的属性是全局属性，因为为了比较行为，需要计算 *f* (0)和 *f* (1)函数(见图 [4-21](#Fig21) )。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig21_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig21_HTML.jpg)

图 4-21

Deutsch 算法的电路[37](来源[35])

Deutsch 算法的主要目标是通过获得关于全局状态的信息来找到最终状态∣*ψ*T2】T3】ft5】⟩。该算法通过使用叠加态来实现这一点，该叠加态是系统由于量子并行性的性质而实现的。最终状态计算如下。

![$$ \left|{\psi}_f\Big\rangle =\left(H\otimes I\right){U}_f\left(H\otimes H\right)\right|01\Big\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equba.png)

(4.38)

其中系统的初始状态是∣*ψ*T2】T3】It5】⟩=∣01⟩，⊗照常表示状态的张量积。

以下是 Deutsch 算法的步骤。

1.  Evaluate ∣*ψ*<sub>*i*</sub>⟩ by applying Hadamard gates to the input states. By the definition of Hadamard gates, this action produces a product state of superposition. To calculate ∣*ψ*<sub>*i* + 1</sub>⟩, we have the following.

    ![$$ \mid {\psi}_i\left\rangle =\mid 01\right\rangle $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbb.png)

![$$ \left|{\psi}_{i+1}\Big\rangle =\left(H\otimes H\right)\right|01\Big\rangle =\left[\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right)\right]\left[\frac{1}{\sqrt{2}}\left(|0\Big\rangle -|1\Big\rangle \right)\right] $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbc.png)

![$$ =\frac{1}{2}\left(|00\Big\rangle -|01\Big\rangle +|10\Big\rangle -|11\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbd.png)

该操作创建一个叠加状态，包含组合的所有可能值( *x* ， *f* ( *x* ))。

1.  In step 2, we apply *U*<sub>*f*</sub> to ∣*ψ*<sub>*i* + 1</sub>⟩ as follows.

    ![$$ \mid {\psi}_{i+2}\left\rangle ={U}_f\mid {\psi}_{i+1}\right\rangle =\frac{1}{2}\left(|0\Big\rangle |f(0)\Big\rangle -|0\Big\rangle |1\oplus f(0)\Big\rangle +|1\Big\rangle |f(1)\Big\rangle -|1\Big\rangle |1\oplus f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Eqube.png)

2.  在这一步，我们把我们的分析分成两种情况:当 *f* ( *x* )平衡时和当它恒定时。

    Case 1: *f*   (*x*) is constant ⇒ *f*   (0) = *f*   (1). Therefore, substituting *f*   (0) for *f*   (1) in ∣*ψ*<sub>*i* + 2</sub>⟩, we have

    ![$$ \mid {\psi}_{i+2}\Big\rangle =\frac{1}{2}\left(|0\Big\rangle |f(0)\Big\rangle -|0\Big\rangle |1\oplus f(0)\Big\rangle +|1\Big\rangle |f(0)\Big\rangle -|1\Big\rangle |1\oplus f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbf.png)

![$$ =\frac{1}{2}\left(\left(|0\Big\rangle +|1\Big\rangle \right)\otimes |f(0)\Big\rangle -\left(|0\Big\rangle +|1\Big\rangle \right)\otimes |1\oplus f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbg.png)

![$$ =\frac{1}{2}\Big(\left(|0\Big\rangle +|1\Big\rangle \right)\otimes \left(|f(0)\Big\rangle -|1\oplus f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbh.png)

![$$ =\frac{1}{\sqrt{2}}\mid +\Big\rangle \otimes \left(|f(0)\Big\rangle -|1\oplus f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbi.png)

![$$ \mid +\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle +|1\Big\rangle \right), $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq15.png)老地方，老地方。这意味着量子位现在处于∣+ ⟩态。因此，

![$$ \mid {\psi}_{i+3}\left\rangle =\frac{1}{\sqrt{2}}\mid 0\right\rangle \otimes \left(|f(0)\Big\rangle -|1\oplus f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbj.png)

这意味着量子位 1 处于∣0⟩.状态因此，如果现在在标准基础上对量子位 1 进行测量，结果是完全确定的 0。

情况二: *f* ( *x* )平衡*f*(0)≦*f*(1)和 *f* (0) ⊕ 1 = *f* (1)和 *f* (1) ⊕ 1 = *f* (0)。

因此，

![$$ \mid {\psi}_{i+3}\Big\rangle =\frac{1}{2}\left(|0\Big\rangle |f(0)\Big\rangle -|0\Big\rangle |f(1)\Big\rangle +|1\Big\rangle |f(1)\Big\rangle -|1\Big\rangle |f(0)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbk.png)

![$$ =\frac{1}{2}\left(\left(|0\Big\rangle -|1\Big\rangle \right)\otimes |f(0)\Big\rangle -\left(|0\Big\rangle -|1\Big\rangle \right)\otimes |f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbl.png)

![$$ =\frac{1}{2}\left(|0\Big\rangle -|1\Big\rangle \right)\otimes \left(|f(0)\Big\rangle -|f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbm.png)

![$$ =\frac{1}{\sqrt{2}}\mid -\Big\rangle \otimes \left(|f(0)\Big\rangle -|f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbn.png)

![$$ \mid -\Big\rangle =\frac{1}{\sqrt{2}}\left(|0\Big\rangle -|1\Big\rangle \right), $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_IEq16.png)老地方，老地方。这意味着量子位现在处于∣− ⟩态。因此，

![$$ \mid {\psi}_{i+3}\left\rangle =\frac{1}{\sqrt{2}}\mid 1\right\rangle \otimes \left(|f(0)\Big\rangle -|f(1)\Big\rangle \right) $$](img/502577_1_En_4_Chapter/502577_1_En_4_Chapter_TeX_Equbo.png)

这意味着量子位 1 处于∣1⟩.状态因此，如果现在在标准基础上对量子位 1 进行测量，结果是完全确定的 1。

总之，如果 *f* 恒定，Deutsch 算法给出 0 作为输出，如果 *f* 平衡，给出 1 作为输出。因此，该算法仅使用*单个查询*来确定 *f* 是平衡的还是恒定的。通过*量子并行*，无需显式评估同一函数的值即可计算该函数的全局属性。

### 带 Cirq 的 Deutsch 算法

现在你已经理解了 Deutsch 的算法，是时候用代码`DeutschCirq` `.ipynb`做一个练习了。清单 [4-6a](#PC32) 中的程序随机选择函数 *f* ( *x* ) = 1 进行求值，并测量第一个量子位的最终状态。首先，我们导入库并构造一个函数来定义类似于图 [4-20](#Fig20) 的电路。清单 [4-6a](#PC32) 定义了以下三个函数。

*   `main()`:生成一个函数(0，1) → (0，1)
    *   调用`moracle`将生成的函数映射到相应的 oracle

    *   用生成的神谕构建量子电路

*   `moracle()`:将函数映射到相应的 oracle

*   `deutsch_circuit()`:创建量子电路
    *   初始化两个量子位

    *   将 X 门应用于量子位 2

    *   对每个量子位应用哈达玛门以产生叠加

    *   应用神谕

    *   将哈达玛门应用于第一个量子位

    *   执行测量

![img/502577_1_En_4_Chapter/502577_1_En_4_Figv_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figv_HTML.jpg)

```py
import cirq
from cirq import H, X, CNOT, measure
import numpy as np
import random

def main():
    # Choose qubits to use.
    q0, q1 = cirq.LineQubit.range(2)

    # Pick a secret 2-bit function and create a circuit to query the oracle.
    secret_function = [random.randint(0, 1) for _ in range(2)]
    oracle = moracle(q0, q1, secret_function)
    print('Secret function:\nf(x) = <{}>'.format(
        ', '.join(str(e) for e in secret_function)))

    # Embed the oracle into a quantum circuit querying it exactly once.
    circuit = deutsch_circuit(q0, q1, oracle)
    print('Circuit:')
    print(circuit)

    # Simulate the circuit.
    simulator = cirq.Simulator()
    result = simulator.run(circuit)
    print('Result of f(0)⊕f(1):')
    print(result)

def moracle(q0, q1, secret_function):
    """ Gates implementing the secret function f(x)."""

    # coverage: ignore
    if secret_function[0]:
        yield [CNOT(q0, q1), X(q1)]

    if secret_function[1]:
        yield CNOT(q0, q1)

def deutsch_circuit(q0, q1, oracle):
    c = cirq.Circuit()

    # Initialize qubits.
    c.append([X(q1), H(q1), H(q0)])

    # Query oracle.
    c.append(oracle)

    # Measure in X basis.
    c.append([H(q0), measure(q0, key='result')])
    return c

Listing 4-6aDeutsch’s Algorithm First Step DeutschCirq.ipynb

```

接下来，在清单 [4-6b](#PC33) 中应用 main 方法。这是运行程序并生成最终输出的方法。

```py
if __name__ == '__main__':
    main()

Listing 4-6bGenerate Output DeutschCirq.ipynb

```

该代码在运行时会给出最终输出。

![img/502577_1_En_4_Chapter/502577_1_En_4_Figw_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Figw_HTML.jpg)

## 量子计算系统

本节旨在给出量子计算(QC)系统和相关关键组件的高级概述。今天的质量控制系统，不管种类如何(基于门控或退火)，都由所有平台通用的三个*主要*组件组成:硬件层、软件层和应用层。在门模型 QC 中，出于信息抽象的原因，软件层与硬件层耦合，并且可以进一步分类为虚拟层、用于量子纠错的层和用于寻址基于门的通用 QC 的编程底层的逻辑层。如图 [4-22](#Fig22) 所示，引用自琼斯、范·米特等人【39】。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig22_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig22_HTML.jpg)

图 4-22

量子计算系统的分层架构(来源[39])

今天的 QC 空间有各种平台，每个平台都支持某些领域的效率。应用程序可以从量子计算中受益。我们现在需要找到合适的设备。量子计算领域是一个广阔的领域，因此，不同的制造 QC 系统的公司已经取得了许多不同的进展。因此，许多不同的量子器件被开发出来，每一种都有自己的优点和局限性。开发应用程序时，了解哪种设备最适合解决特定问题非常重要。

一些最受欢迎的量子设备是基于门的量子计算机，其中使用量子逻辑门对量子位进行操作。你学习了编程和两种基于 gate 的属性，比如本章中的计算机，即 IBM Q(用于 Qiskit)和 Google Cirq。这种 QCs 使用的逻辑门类似于经典计算机中的逻辑门，但是更加复杂多样。你看到了盖茨的例子，包括哈达玛，泡利，CNOT 和旋转。

基于门的量子计算有许多不同的实现方式。

*   **超导量子器件**:最流行的使用噪声量子电路的硬件实现。它们需要用低温技术冷却到接近绝对零度(–273°C)。在这些类型的平台上工作的组织的例子有 IBM、Google 和 Amazon。

*   **囚禁离子设备**:这些平台使用囚禁离子作为量子位。这些设备往往具有非常高保真度的量子位，具有高得多的相干时间，但目前，与超导设备相比，量子位计数较低。专注于这类技术的公司的一个例子是 IonQ。

*   基于光子的设备:这些设备使用光子作为量子位。这些设备往往具有高保真度和快速门控操作，并且不需要制冷。致力于这些技术并取得重大进展的公司是 Xanadu 和 PsiQuantum。

另一种量子计算机使用退火技术。量子退火器，如 D-Wave 建造的量子退火器，在解决优化问题时非常有效。经典的背包问题、旅行推销员问题和最大割问题都可以通过这样的平台非常有效地解决。这是在量子退火机上完成的，首先将量子位初始化为叠加态。在这之后，量子位和它们之间的连接被慢慢调整。在运行结束时，配置对应于感兴趣的最佳解决方案。D-Wave 计算机的工作方式可以总结如下。

*   参数被转换成电压、电流和磁场。这个问题被编程到 D-Wave QPU(量子处理单元)上。

*   量子位自旋从它们的叠加态开始。

*   量子位自旋进化并探索问题空间。

*   当退火过程结束时，系统到达所提交问题的基态或低激发态。

*   读取自旋的状态，应用任何所需的预处理，并将结果返回给用户。

*   每秒钟可以做几百次。

量子控制中一些主要的挑战和国际研究兴趣的主题是*量子纠错*(QEC)*相干性*和*量子存储器*。一些量子计算机，如超导量子设备，容易受到噪声的影响，从而导致误差。这些误差分为三种主要类型:位翻转、相位翻转和读出误差。这些误差可以使用量子误差校正/减轻方法来校正；然而，这可能需要量子电路中额外的量子位和门。

开源软件在量子算法的设计和测试中变得至关重要[38]。许多工具由主要的商业供应商支持，目的是使开发 quantum 软件更容易。这反映了资金充足的开放机器学习框架如何使复杂模型的开发及其在同样复杂的硬件上的执行成为可能。现在有各种各样的量子计算开源软件，涵盖了量子工具链的所有阶段，从量子硬件接口到量子编译器，再到量子算法的实现，以及所有的量子计算范式，包括量子退火和离散及连续可变门模型量子计算。

门模型量子计算机通常具有如图 [4-23](#Fig23) 所示的工作流程。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig23_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig23_HTML.jpg)

图 4-23

门控模型 QC 中的工作流程(来源[38])

在门模型中，问题是在高层次上定义的。基于问题的性质选择合适的量子算法。接下来，量子算法被表达为一个量子电路，需要被编译成一个特定的量子门集合。最后，量子电路要么在量子处理器上执行，要么用量子计算机模拟器模拟。

图 [4-24](#Fig24) 显示了使用量子退火时的典型工作流程。

![img/502577_1_En_4_Chapter/502577_1_En_4_Fig24_HTML.jpg](img/502577_1_En_4_Chapter/502577_1_En_4_Fig24_HTML.jpg)

图 4-24

绝热 QC 中的工作流程(来源[38])

在量子退火过程中，作为第一步，问题被定义，然后被编码成 Ising 型哈密顿量，该哈密顿量被可视化为图形。第二步，通过小图嵌入将哈密顿问题嵌入到量子硬件图中。最后，量子退火器或经典解算器被用于采样对应于原始问题的(近)最优解的低能态。

图 [4-23](#Fig23) 和 [4-24](#Fig24) 中的过程从高层次的问题定义开始(例如，解决给定图上的旅行商问题或背包问题)。解决这样一个问题的第一步是决定一个合适的量子算法。量子算法被定义为解决一个问题的有限步骤序列，其中每个步骤都可以在量子计算机上执行。作为一个例子，在旅行推销员问题中，我们面临一个离散的最优化问题。因此，用户可以考虑一个适当的算法(例如，量子近似优化算法(QAOA) [40]，设计用于噪声离散门模型量子计算机或量子退火，以找到最佳解决方案)。

## 摘要

量子信息是指可以物理存储在量子系统中的数据。量子信息理论是研究这种信息如何被编码、测量和操纵的。本章介绍了 Qiskit 和 Cirq 中的基本算法、量子并行性、隐形传态和相关编程。下一章涵盖了量子机器学习基础的要点，如 Deutsch-Jozsa 算法，优化理论，信息编码和量子复杂性。***